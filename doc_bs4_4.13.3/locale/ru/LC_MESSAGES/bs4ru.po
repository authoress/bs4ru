# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2022, Leonard Richardson & authoress
# This file is distributed under the same license as the bs4ru package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: bs4ru \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-28 20:54+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ru\n"
"Language-Team: ru <LL@li.org>\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"

#: ../../bs4ru.rst:2
msgid "Beautiful Soup Documentation"
msgstr "Документация Beautiful Soup "

#: ../../bs4ru.rst:-1
msgid ""
"\"The Fish-Footman began by producing from under his arm a great letter, "
"nearly as large as himself.\""
msgstr ""
"\"Лакей Карась начал с того, что вытащил из-под мышки огромный конверт "
"(чуть ли не больше его самого).\""

#: ../../bs4ru.rst:8
msgid ""
"`Beautiful Soup <http://www.crummy.com/software/BeautifulSoup/>`_ is a "
"Python library for pulling data out of HTML and XML files. It works with "
"your favorite parser to provide idiomatic ways of navigating, searching, "
"and modifying the parse tree. It commonly saves programmers hours or days"
" of work."
msgstr ""
"`Beautiful Soup <http://www.crummy.com/software/BeautifulSoup/>`_ — это "
"библиотека Python для извлечения данных из файлов HTML и XML. Она "
"работает с вашим любимым парсером, чтобы дать вам естественные способы "
"навигации, поиска и изменения дерева разбора. Она обычно экономит "
"программистам часы и дни работы. "

#: ../../bs4ru.rst:14
msgid ""
"These instructions illustrate all major features of Beautiful Soup 4, "
"with examples. I show you what the library is good for, how it works, how"
" to use it, how to make it do what you want, and what to do when it "
"violates your expectations."
msgstr ""
"Эти инструкции иллюстрируют все основные функции Beautiful Soup 4 на "
"примерах. Я покажу вам, для чего нужна библиотека, как она работает, как "
"ее использовать, как заставить ее делать то, что вы хотите, и что нужно "
"делать, когда она не оправдывает ваши ожидания. "

#: ../../bs4ru.rst:19
msgid ""
"This document covers Beautiful Soup version 4.13.3. The examples in this "
"documentation were written for Python 3.8."
msgstr ""
"Эта документация относится к Beautiful Soup версии 4.13.3. Примеры в "
"документации приведены для Python 3.8. "

#: ../../bs4ru.rst:22
msgid ""
"You might be looking for the documentation for `Beautiful Soup 3 "
"<http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html>`_. "
"If so, you should know that Beautiful Soup 3 is no longer being developed"
" and that all support for it was dropped on December 31, 2020. If you "
"want to learn about the differences between Beautiful Soup 3 and "
"Beautiful Soup 4, see `Porting code to BS4`_."
msgstr ""
"Возможно, вы ищете документацию для `Beautiful Soup 3 "
"<http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html>`_. "
"Если это так, имейте в виду, что Beautiful Soup 3 больше не развивается, "
"и что поддержка этой версии прекращена 31 декабря 2020 года. Если вы "
"хотите узнать о различиях между Beautiful Soup 3 и Beautiful Soup 4, "
"читайте раздел `Перенос кода на BS4`_. "

#: ../../bs4ru.rst:29
msgid ""
"This documentation has been translated into other languages by Beautiful "
"Soup users:"
msgstr ""
"Эта документация переведена на другие языки пользователями Beautiful "
"Soup: "

#: ../../bs4ru.rst:32
msgid ""
"`这篇文档当然还有中文版. "
"<https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/>`_"
msgstr ""
"`这篇文档当然还有中文版. "
"<https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/>`_"

#: ../../bs4ru.rst:33
msgid "このページは日本語で利用できます(`外部リンク <http://kondou.com/BS4/>`_)"
msgstr "このページは日本語で利用できます(`外部リンク <http://kondou.com/BS4/>`_)"

#: ../../bs4ru.rst:34
msgid ""
"`이 문서는 한국어 번역도 가능합니다. "
"<https://www.crummy.com/software/BeautifulSoup/bs4/doc.ko/>`_"
msgstr ""
"`이 문서는 한국어 번역도 가능합니다. "
"<https://www.crummy.com/software/BeautifulSoup/bs4/doc.ko/>`_"

#: ../../bs4ru.rst:35
msgid ""
"`Este documento também está disponível em Português do Brasil. "
"<https://www.crummy.com/software/BeautifulSoup/bs4/doc.ptbr>`_"
msgstr ""
"`Este documento também está disponível em Português do Brasil. "
"<https://www.crummy.com/software/BeautifulSoup/bs4/doc.ptbr>`_"

#: ../../bs4ru.rst:36
msgid ""
"`Este documento también está disponible en una traducción al español. "
"<https://www.crummy.com/software/BeautifulSoup/bs4/doc.es/>`_"
msgstr ""
"`Este documento también está disponible en una traducción al español. "
"<https://www.crummy.com/software/BeautifulSoup/bs4/doc.es/>`_"

#: ../../bs4ru.rst:37
msgid ""
"`Эта документация доступна на русском языке. "
"<https://www.crummy.com/software/BeautifulSoup/bs4/doc.ru/>`_"
msgstr ""
"`Эта документация доступна на русском языке. "
"<http://bs4ru.geekwriter.ru>`_"

#: ../../bs4ru.rst:40
msgid "Getting help"
msgstr "Техническая поддержка "

#: ../../bs4ru.rst:42
msgid ""
"If you have questions about Beautiful Soup, or run into problems, `send "
"mail to the discussion group "
"<https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup>`_. If "
"your problem involves parsing an HTML document, be sure to mention "
":ref:`what the diagnose() function says <diagnose>` about that document."
msgstr ""
"Если у вас есть вопросы о Beautiful Soup или возникли проблемы, "
"`отправьте сообщение в дискуссионную группу "
"<https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup>`_. "
"Если ваша проблема связана с разбором HTML-документа, не забудьте "
"упомянуть, :ref:`что говорит о нем функция diagnose() <diagnose>`. "

#: ../../bs4ru.rst:49
msgid ""
"When reporting an error in this documentation, please mention which "
"translation you're reading."
msgstr "Сообщая об ошибке в этой документации, укажите, какой перевод вы читаете."

#: ../../bs4ru.rst:53
msgid "API documentation"
msgstr "Документация API"

#: ../../bs4ru.rst:55
msgid ""
"This document is written like an instruction manual, but you can also "
"read :doc:`traditional API documentation <api/modules>` generated from "
"the Beautiful Soup source code. If you want details about Beautiful "
"Soup's internals, or a feature not covered in this document, try the API "
"documentation."
msgstr ""
"Документ, который вы читаете -- это руководство пользователя. Также вы можете почитать `традиционную документацию API <https://www.crummy.com/software/BeautifulSoup/bs4/doc/api/modules.html>`_, сгенерированную из исходного кода Beautiful Soup. Если вам нужны подробности о внутренних компонентах Beautiful Soup или о функциях, не описанных в этом документе, попробуйте найти их в документации API."

#: ../../bs4ru.rst:62
msgid "Quick Start"
msgstr "Быстрый старт "

#: ../../bs4ru.rst:64
msgid ""
"Here's an HTML document I'll be using as an example throughout this "
"document. It's part of a story from *Alice in Wonderland*::"
msgstr ""
"Вот HTML-документ, который я буду использовать в качестве примера в этой "
"документации. Это фрагмент из «Алисы в стране чудес»:: "

#: ../../bs4ru.rst:80
msgid ""
"Running the \"three sisters\" document through Beautiful Soup gives us a "
":py:class:`BeautifulSoup` object, which represents the document as a "
"nested data structure::"
msgstr ""
"Прогон документа через Beautiful Soup дает нам объект "
":py:class:`BeautifulSoup`, который представляет документ в виде вложенной"
" структуры данных:: "

#: ../../bs4ru.rst:121
msgid "Here are some simple ways to navigate that data structure::"
msgstr "Вот несколько простых способов навигации по этой структуре данных:: "

#: ../../bs4ru.rst:152
msgid ""
"One common task is extracting all the URLs found within a page's <a> "
"tags::"
msgstr ""
"Одна из распространенных задач — извлечь все URL-адреса, найденные на "
"странице в тегах <a>:: "

#: ../../bs4ru.rst:160
msgid "Another common task is extracting all the text from a page::"
msgstr "Другая распространенная задача — извлечь весь текст со страницы:: "

#: ../../bs4ru.rst:175
msgid "Does this look like what you need? If so, read on."
msgstr "Это похоже на то, что вам нужно? Если да, продолжайте читать. "

#: ../../bs4ru.rst:178
msgid "Installing Beautiful Soup"
msgstr "Установка Beautiful Soup "

#: ../../bs4ru.rst:180
msgid ""
"If you're using a recent version of Debian or Ubuntu Linux, you can "
"install Beautiful Soup with the system package manager:"
msgstr ""
"Если вы используете последнюю версию Debian или Ubuntu Linux, вы можете "
"установить Beautiful Soup с помощью системы управления пакетами: "

#: ../../bs4ru.rst:183
msgid ":kbd:`$ apt-get install python3-bs4`"
msgstr ":kbd:`$ apt-get install python3-bs4` "

#: ../../bs4ru.rst:185
msgid ""
"Beautiful Soup 4 is published through PyPi, so if you can't install it "
"with the system packager, you can install it with ``easy_install`` or "
"``pip``. The package name is ``beautifulsoup4``. Make sure you use the "
"right version of ``pip`` or ``easy_install`` for your Python version "
"(these may be named ``pip3`` and ``easy_install3`` respectively)."
msgstr ""
"Beautiful Soup 4 публикуется через PyPi, поэтому, если вы не можете "
"установить библиотеку с помощью системы управления пакетами, можно "
"установить с помощью ``easy_install`` или ``pip``. Пакет называется "
"``beautifulsoup4``. Убедитесь, что вы используете версию ``pip`` или "
"``easy_install``, предназначенную для вашей версии Python (они могут "
"называться ``pip3`` и ``easy_install3`` соответственно). "

#: ../../bs4ru.rst:191
msgid ":kbd:`$ easy_install beautifulsoup4`"
msgstr ":kbd:`$ easy_install beautifulsoup4` "

#: ../../bs4ru.rst:193
msgid ":kbd:`$ pip install beautifulsoup4`"
msgstr ":kbd:`$ pip install beautifulsoup4` "

#: ../../bs4ru.rst:195
msgid ""
"(The :py:class:`BeautifulSoup` package is *not* what you want. That's the"
" previous major release, `Beautiful Soup 3`_. Lots of software uses BS3, "
"so it's still available, but if you're writing new code you should "
"install ``beautifulsoup4``.)"
msgstr ""
"(:py:class:`BeautifulSoup` — это *не тот* пакет, который вам нужен. Это "
"предыдущий основной релиз, `Beautiful Soup 3`_. Многие программы "
"используют BS3, так что он все еще доступен, но если вы пишете новый код,"
" нужно установить ``beautifulsoup4``.) "

#: ../../bs4ru.rst:200
msgid ""
"If you don't have ``easy_install`` or ``pip`` installed, you can "
"`download the Beautiful Soup 4 source tarball "
"<http://www.crummy.com/software/BeautifulSoup/download/4.x/>`_ and "
"install it with ``setup.py``."
msgstr ""
"Если у вас не установлены ``easy_install`` или ``pip``, вы можете "
"`скачать архив с исходным кодом Beautiful Soup 4 "
"<http://www.crummy.com/software/BeautifulSoup/download/4.x/>`_ и "
"установить его с помощью ``setup.py``. "

#: ../../bs4ru.rst:205
msgid ":kbd:`$ python setup.py install`"
msgstr ":kbd:`$ python setup.py install` "

#: ../../bs4ru.rst:207
msgid ""
"If all else fails, the license for Beautiful Soup allows you to package "
"the entire library with your application. You can download the tarball, "
"copy its ``bs4`` directory into your application's codebase, and use "
"Beautiful Soup without installing it at all."
msgstr ""
"Если ничего не помогает, лицензия на Beautiful Soup позволяет упаковать "
"библиотеку целиком вместе с вашим приложением. Вы можете скачать "
"tar-архив, скопировать из него в кодовую базу вашего приложения каталог "
"``bs4`` и использовать Beautiful Soup, не устанавливая его вообще. "

#: ../../bs4ru.rst:212
msgid ""
"I use Python 3.10 to develop Beautiful Soup, but it should work with "
"other recent versions."
msgstr ""
"Я использую Python 3.10 для разработки, но библиотека должна работать и с"
" более поздними версиями Python. "

#: ../../bs4ru.rst:219
msgid "Installing a parser"
msgstr "Установка парсера "

#: ../../bs4ru.rst:221
msgid ""
"Beautiful Soup supports the HTML parser included in Python's standard "
"library, but it also supports a number of third-party Python parsers. One"
" is the `lxml parser <http://lxml.de/>`_. Depending on your setup, you "
"might install lxml with one of these commands:"
msgstr ""
"Beautiful Soup поддерживает парсер HTML, включенный в стандартную "
"библиотеку Python, а также ряд сторонних парсеров на Python. Одним из них"
" является `парсер lxml <http://lxml.de/>`_. В зависимости от ваших "
"настроек, вы можете установить lxml с помощью одной из следующих команд: "

#: ../../bs4ru.rst:226
msgid ":kbd:`$ apt-get install python-lxml`"
msgstr ":kbd:`$ apt-get install python-lxml` "

#: ../../bs4ru.rst:228
msgid ":kbd:`$ easy_install lxml`"
msgstr ":kbd:`$ easy_install lxml` "

#: ../../bs4ru.rst:230
msgid ":kbd:`$ pip install lxml`"
msgstr ":kbd:`$ pip install lxml` "

#: ../../bs4ru.rst:232
msgid ""
"Another alternative is the pure-Python `html5lib parser "
"<http://code.google.com/p/html5lib/>`_, which parses HTML the way a web "
"browser does. Depending on your setup, you might install html5lib with "
"one of these commands:"
msgstr ""
"Другая альтернатива — написанный исключительно на Python `парсер html5lib"
" <http://code.google.com/p/html5lib/>`_, который разбирает HTML таким же "
"образом, как это делает веб-браузер. В зависимости от ваших настроек, вы "
"можете установить html5lib с помощью одной из этих команд: "

#: ../../bs4ru.rst:237
msgid ":kbd:`$ apt-get install python3-html5lib`"
msgstr ":kbd:`$ apt-get install python3-html5lib` "

#: ../../bs4ru.rst:239
msgid ":kbd:`$ pip install html5lib`"
msgstr ":kbd:`$ pip install html5lib` "

#: ../../bs4ru.rst:241
msgid ""
"This table summarizes the advantages and disadvantages of each parser "
"library:"
msgstr "Эта таблица суммирует преимущества и недостатки каждого парсера: "

#: ../../bs4ru.rst:244
msgid "Parser"
msgstr "Парсер "

#: ../../bs4ru.rst:244
msgid "Typical usage"
msgstr "Типичное использование "

#: ../../bs4ru.rst:244
msgid "Advantages"
msgstr "Преимущества "

#: ../../bs4ru.rst:244
msgid "Disadvantages"
msgstr "Недостатки "

#: ../../bs4ru.rst:246
msgid "Python's html.parser"
msgstr "html.parser от Python "

#: ../../bs4ru.rst:246
msgid "``BeautifulSoup(markup, \"html.parser\")``"
msgstr "``BeautifulSoup(markup, \"html.parser\")`` "

#: ../../bs4ru.rst:246
msgid "Batteries included"
msgstr "Входит в комплект "

#: ../../bs4ru.rst:247
msgid "Decent speed"
msgstr "Приличная скорость "

#: ../../bs4ru.rst:246
msgid "Not as fast as lxml, less lenient than html5lib."
msgstr "Не такой быстрый, как lxml, более строгий, чем html5lib "

#: ../../bs4ru.rst:250
msgid "lxml's HTML parser"
msgstr "HTML-парсер в lxml "

#: ../../bs4ru.rst:250
msgid "``BeautifulSoup(markup, \"lxml\")``"
msgstr "``BeautifulSoup(markup, \"lxml\")`` "

#: ../../bs4ru.rst:250 ../../bs4ru.rst:252
msgid "Very fast"
msgstr "Очень быстрый "

#: ../../bs4ru.rst:250 ../../bs4ru.rst:252
msgid "External C dependency"
msgstr "Внешняя зависимость от C "

#: ../../bs4ru.rst:252
msgid "lxml's XML parser"
msgstr "XML-парсер в lxml "

#: ../../bs4ru.rst:252
msgid "``BeautifulSoup(markup, \"lxml-xml\")`` ``BeautifulSoup(markup, \"xml\")``"
msgstr ""
"``BeautifulSoup(markup, \"lxml-xml\")`` ``BeautifulSoup(markup, "
"\"xml\")`` "

#: ../../bs4ru.rst:253
msgid "The only currently supported XML parser"
msgstr "Единственный XML-парсер, который сейчас поддерживается "

#: ../../bs4ru.rst:256
msgid "html5lib"
msgstr "html5lib "

#: ../../bs4ru.rst:256
msgid "``BeautifulSoup(markup, \"html5lib\")``"
msgstr "``BeautifulSoup(markup, \"html5lib\")`` "

#: ../../bs4ru.rst:256
msgid "Extremely lenient"
msgstr "Очень нестрогий "

#: ../../bs4ru.rst:257
msgid "Parses pages the same way a web browser does"
msgstr "Разбирает страницы так же, как это делает браузер "

#: ../../bs4ru.rst:259
msgid "Creates valid HTML5"
msgstr "Создает валидный HTML5 "

#: ../../bs4ru.rst:256
msgid "Very slow"
msgstr "Очень медленный "

#: ../../bs4ru.rst:257
msgid "External Python dependency"
msgstr "Внешняя зависимость от Python "

#: ../../bs4ru.rst:262
msgid "If you can, I recommend you install and use lxml for speed."
msgstr ""
"Я рекомендую по возможности установить и использовать lxml для "
"быстродействия."

#: ../../bs4ru.rst:264
msgid ""
"Note that if a document is invalid, different parsers will generate "
"different Beautiful Soup trees for it. See `Differences between parsers`_"
" for details."
msgstr ""
"Обратите внимание, что если документ невалиден, различные парсеры будут "
"генерировать дерево Beautiful Soup для этого документа по-разному. Ищите "
"подробности в разделе `Различия между парсерами`_. "

#: ../../bs4ru.rst:269
msgid "Making the soup"
msgstr "Приготовление супа "

#: ../../bs4ru.rst:271
msgid ""
"To parse a document, pass it into the :py:class:`BeautifulSoup` "
"constructor. You can pass in a string or an open filehandle::"
msgstr ""
"Чтобы разобрать документ, передайте его в конструктор "
":py:class:`BeautifulSoup`. Вы можете передать строку или открытый "
"дескриптор файла:: "

#: ../../bs4ru.rst:281
msgid ""
"First, the document is converted to Unicode, and HTML entities are "
"converted to Unicode characters::"
msgstr ""
"Первым делом документ конвертируется в Unicode, а HTML-мнемоники "
"конвертируются в символы Unicode:: "

#: ../../bs4ru.rst:287
msgid ""
"Beautiful Soup then parses the document using the best available parser. "
"It will use an HTML parser unless you specifically tell it to use an XML "
"parser. (See `Parsing XML`_.)"
msgstr ""
"Затем Beautiful Soup анализирует документ, используя лучший из доступных "
"парсеров. Библиотека будет использовать HTML-парсер, если вы явно не "
"укажете, что нужно использовать XML-парсер. (См. `Разбор XML`_.) "

#: ../../bs4ru.rst:292
msgid "Kinds of objects"
msgstr "Виды объектов "

#: ../../bs4ru.rst:294
msgid ""
"Beautiful Soup transforms a complex HTML document into a complex tree of "
"Python objects. But you'll only ever have to deal with about four *kinds*"
" of objects: :py:class:`Tag`, :py:class:`NavigableString`, "
":py:class:`BeautifulSoup`, and :py:class:`Comment`. These objects "
"represent the HTML *elements* that comprise the page."
msgstr ""
"Beautiful Soup превращает сложный HTML-документ в сложное дерево объектов"
" Python. Однако вам придется иметь дело только с четырьмя *видами* "
"объектов: :py:class:`Tag`, :py:class:`NavigableString`, "
":py:class:`BeautifulSoup` и :py:class:`Comment`. Эти объекты представляют"
" собой *элементы* HTML, составляющие страницу."

#: ../../bs4ru.rst:302
msgid ""
"A :py:class:`Tag` object corresponds to an XML or HTML tag in the "
"original document."
msgstr ""
"Объект :py:class:`Tag` соответствует тегу XML или HTML в исходном "
"документе:: "

#: ../../bs4ru.rst:311
msgid ""
"Tags have a lot of attributes and methods, and I'll cover most of them in"
" `Navigating the tree`_ and `Searching the tree`_. For now, the most "
"important methods of a tag are for accessing its name and attributes."
msgstr ""
"У объекта Tag (далее «тег») много атрибутов и методов, и я расскажу о "
"большинстве из них в разделах `Навигация по дереву`_ и `Поиск по "
"дереву`_. На данный момент наиболее важными методами тега являются "
"используемые для доступа к его имеми и атрибутам. "

#: ../../bs4ru.rst:317
msgid "Every tag has a name::"
msgstr "У каждого тега есть имя:: "

#: ../../bs4ru.rst:322
msgid ""
"If you change a tag's name, the change will be reflected in any markup "
"generated by Beautiful Soup down the line::"
msgstr ""
"Если вы измените имя тега, это изменение будет отражено в любой HTML- "
"разметке, созданной Beautiful Soup в дальнейшем::"

#: ../../bs4ru.rst:331
msgid ""
"An HTML or XML tag may have any number of attributes. The tag ``<b "
"id=\"boldest\">`` has an attribute \"id\" whose value is \"boldest\". You"
" can access a tag's attributes by treating the tag like a dictionary::"
msgstr ""
"У тега HTML или XML может быть любое количество атрибутов. Тег ``<b id = "
"\"boldest\">`` имеет атрибут \"id\", значение которого равно \"boldest\"."
" Вы можете получить доступ к атрибутам тега, обращаясь с тегом как со "
"словарем:: "

#: ../../bs4ru.rst:340
msgid "You can access the dictionary of attributes directly as ``.attrs``::"
msgstr "Вы можете получить доступ к словарю атрибутов напрямую как к ``.attrs``:: "

#: ../../bs4ru.rst:347
msgid ""
"You can add, remove, and modify a tag's attributes. Again, this is done "
"by treating the tag as a dictionary::"
msgstr ""
"Вы можете добавлять, удалять и изменять атрибуты тега. Опять же, это "
"делается путем обращения с тегом как со словарем::  tag  tag "

#: ../../bs4ru.rst:368
msgid "Multi-valued attributes"
msgstr "Многозначные атрибуты "

#: ../../bs4ru.rst:370
msgid ""
"HTML 4 defines a few attributes that can have multiple values. HTML 5 "
"removes a couple of them, but defines a few more. The most common multi-"
"valued attribute is ``class`` (that is, a tag can have more than one CSS "
"class). Others include ``rel``, ``rev``, ``accept-charset``, ``headers``,"
" and ``accesskey``. By default, Beautiful Soup stores the value(s) of a "
"multi-valued attribute as a list::"
msgstr ""
"В HTML 4 определено несколько атрибутов, которые могут иметь множество "
"значений. В HTML 5 пара таких атрибутов удалена, но определено еще "
"несколько. Самый распространенный из многозначных атрибутов — это "
"``class`` (т. е. тег может иметь более одного класса CSS). Среди прочих "
"``rel``, ``rev``, ``accept-charset``, ``headers`` и ``accesskey``. По "
"умолчанию Beautiful Soup хранит значение(я) многозначного атрибута в виде"
" списка:: "

#: ../../bs4ru.rst:385
msgid ""
"When you turn a tag back into a string, the values of any multi-valued "
"attributes are consolidated::"
msgstr ""
"Когда вы преобразовываете тег обратно в строку, значения многозначных "
"атрибутов объединяются:: "

#: ../../bs4ru.rst:395
msgid ""
"If an attribute *looks* like it has more than one value, but it's not a "
"multi-valued attribute as defined by any version of the HTML standard, "
"Beautiful Soup stores it as a simple string::"
msgstr ""
"Если атрибут *выглядит* так, будто он имеет более одного значения, но это"
" не многозначный атрибут, определенный какой-либо версией HTML- "
"стандарта, Beautiful Soup хранит его в виде простой строки:: "

#: ../../bs4ru.rst:403
msgid ""
"You can force all attributes to be stored as strings by passing "
"``multi_valued_attributes=None`` as a keyword argument into the "
":py:class:`BeautifulSoup` constructor::"
msgstr ""
"Вы можете включить хранение значений атрибутов в виде строки, передав "
"``multi_valued_attributes = None`` в качестве именованного аргумента в "
"конструктор :py:class:`BeautifulSoup`:: "

#: ../../bs4ru.rst:411
msgid ""
"You can use ``get_attribute_list`` to always return the value in a list "
"container, whether it's a string or multi-valued attribute value::"
msgstr ""
"Вы можете использовать ``get_attribute_list``, чтобы получить значение в "
"контейнере списка, независимо от того, является ли атрибут многозначным "
"или нет::   "

#: ../../bs4ru.rst:419
msgid "If you parse a document as XML, there are no multi-valued attributes::"
msgstr "Если вы разбираете документ как XML, многозначных атрибутов не будет:: "

#: ../../bs4ru.rst:425
msgid ""
"Again, you can configure this using the ``multi_valued_attributes`` "
"argument::"
msgstr ""
"Опять же, вы можете поменять настройку, используя аргумент "
"``multi_valued_attributes``:: "

#: ../../bs4ru.rst:432
msgid ""
"You probably won't need to do this, but if you do, use the defaults as a "
"guide. They implement the rules described in the HTML specification::"
msgstr ""
"Вряд ли вам это пригодится, но если все-таки будет нужно, "
"руководствуйтесь значениями по умолчанию. Они реализуют правила, "
"описанные в спецификации HTML:: "

#: ../../bs4ru.rst:442
msgid ""
"A tag can contain strings as pieces of text. Beautiful Soup uses the "
":py:class:`NavigableString` class to contain these pieces of text::"
msgstr ""
"Тег может содержать строки как фрагменты текста. Beautiful Soup "
"использует класс :py:class:`NavigableString` для хранения этих фрагментов"
" текста:: "

#: ../../bs4ru.rst:452
msgid ""
"A :py:class:`NavigableString` is just like a Python Unicode string, "
"except that it also supports some of the features described in "
"`Navigating the tree`_ and `Searching the tree`_. You can convert a "
":py:class:`NavigableString` to a Unicode string with ``str``::"
msgstr ""
":py:class:`NavigableString` похожа на строку Unicode в Python, не считая "
"того, что она также поддерживает некоторые функции, описанные в разделах "
"`Навигация по дереву`_ и `Поиск по дереву`_. Вы можете конвертировать "
":py:class:`NavigableString` в строку Unicode с помощью ``str``:: "

#: ../../bs4ru.rst:463
msgid ""
"You can't edit a string in place, but you can replace one string with "
"another, using :ref:`replace_with()`::"
msgstr ""
"Вы не можете редактировать строку непосредственно, но вы можете заменить "
"одну строку другой, используя :ref:`replace_with()`:: "

#: ../../bs4ru.rst:470
msgid ""
":py:class:`NavigableString` supports most of the features described in "
"`Navigating the tree`_ and `Searching the tree`_, but not all of them. In"
" particular, since a string can't contain anything (the way a tag may "
"contain a string or another tag), strings don't support the ``.contents``"
" or ``.string`` attributes, or the ``find()`` method."
msgstr ""
":py:class:`NavigableString` поддерживает большинство функций, описанных в"
" разделах `Навигация по дереву`_ и `Поиск по дереву`_, но не все. В "
"частности, поскольку строка не может ничего содержать (в том смысле, в "
"котором тег может содержать строку или другой тег), строки не "
"поддерживают атрибуты ``.contents`` и ``.string`` или метод ``find()``. "

#: ../../bs4ru.rst:476
msgid ""
"If you want to use a :py:class:`NavigableString` outside of Beautiful "
"Soup, you should call ``unicode()`` on it to turn it into a normal Python"
" Unicode string. If you don't, your string will carry around a reference "
"to the entire Beautiful Soup parse tree, even when you're done using "
"Beautiful Soup. This is a big waste of memory."
msgstr ""
"Если вы хотите использовать :py:class:`NavigableString` вне Beautiful "
"Soup, вам нужно вызвать метод ``unicode()``, чтобы превратить ее в "
"обычную для Python строку Unicode. Если вы этого не сделаете, ваша строка"
" будет тащить за собой ссылку на все дерево разбора Beautiful Soup, даже "
"когда вы закончите использовать Beautiful Soup. Это большой расход "
"памяти. "

#: ../../bs4ru.rst:486
msgid ""
"The :py:class:`BeautifulSoup` object represents the parsed document as a "
"whole. For most purposes, you can treat it as a :py:class:`Tag` object. "
"This means it supports most of the methods described in `Navigating the "
"tree`_ and `Searching the tree`_."
msgstr ""
"Объект :py:class:`BeautifulSoup` представляет разобранный документ как "
"единое целое. В большинстве случаев вы можете рассматривать его как "
"объект :py:class:`Tag`. Это означает, что он поддерживает большинство "
"методов, описанных в разделах `Навигация по дереву`_ и `Поиск по "
"дереву`_. "

#: ../../bs4ru.rst:491
msgid ""
"You can also pass a :py:class:`BeautifulSoup` object into one of the "
"methods defined in `Modifying the tree`_, just as you would a "
":py:class:`Tag`. This lets you do things like combine two parsed "
"documents::"
msgstr ""
"Вы также можете передать объект :py:class:`BeautifulSoup` в один из "
"методов, перечисленных в разделе `Изменение дерева`_, по аналогии с "
":py:class:`Tag`. Это позволяет вам делать такие вещи, как объединение "
"двух разобранных документов:: "

#: ../../bs4ru.rst:503
msgid ""
"Since the :py:class:`BeautifulSoup` object doesn't correspond to an "
"actual HTML or XML tag, it has no name and no attributes. But sometimes "
"it's useful to reference its ``.name`` (such as when writing code that "
"works with both :py:class:`Tag` and :py:class:`BeautifulSoup` objects), "
"so it's been given the special ``.name`` \"[document]\"::"
msgstr ""
"Поскольку объект :py:class:`BeautifulSoup` не соответствует "
"действительному HTML- или XML-тегу, у него нет имени и атрибутов. Однако "
"иногда полезно ссылаться на ``.name`` объекта (например, при написании "
"кода, который работает как с объектами :py:class:`Tag`, так и "
":py:class:`BeautifulSoup`), поэтому ему было присвоено специальное имя "
"``.name`` \"[document]\":: "

#: ../../bs4ru.rst:513
msgid "Special strings"
msgstr "Специальные строки"

#: ../../bs4ru.rst:515
msgid ""
":py:class:`Tag`, :py:class:`NavigableString`, and "
":py:class:`BeautifulSoup` cover almost everything you'll see in an HTML "
"or XML file, but there are a few leftover bits. The main one you'll "
"probably encounter is the :py:class:`Comment`."
msgstr ""
":py:class:`Tag`, :py:class:`NavigableString` и :py:class:`BeautifulSoup` "
"охватывают почти все, с чем вы столкнетесь в файле HTML или XML, но "
"осталось еще немного. Пожалуй, единственное, с чем вам придется "
"столкнуться, это :py:class:`Comment`:: "

#: ../../bs4ru.rst:530
msgid ""
"The :py:class:`Comment` object is just a special type of "
":py:class:`NavigableString`::"
msgstr ""
"Объект :py:class:`Comment` — это просто особый тип "
":py:class:`NavigableString`:: "

#: ../../bs4ru.rst:535
msgid ""
"But when it appears as part of an HTML document, a :py:class:`Comment` is"
" displayed with special formatting::"
msgstr ""
"Но когда он появляется как часть HTML-документа, :py:class:`Comment` "
"отображается со специальным форматированием:: "

#: ../../bs4ru.rst:544
msgid "For HTML documents"
msgstr "Для документов HTML"

#: ../../bs4ru.rst:546
msgid ""
"Beautiful Soup defines a few :py:class:`NavigableString` subclasses to "
"contain strings found inside specific HTML tags. This makes it easier to "
"pick out the main body of the page, by ignoring strings that probably "
"represent programming directives found within the page. *(These classes "
"are new in Beautiful Soup 4.9.0, and the html5lib parser doesn't use "
"them.)*"
msgstr ""
"Beautiful Soup определяет несколько подклассов "
":py:class:`NavigableString`, которые содержат строки, найденные внутри "
"определенных HTML-тегов. Это облегчает выделение основной части страницы "
"путем игнорирования строк, которые, вероятно, представляют собой "
"программные директивы, найденные на странице. *(Эти классы являются "
"новыми в Beautiful Soup 4.9.0, и парсер html5lib их не использует.)*"

#: ../../bs4ru.rst:555
msgid ""
"A :py:class:`NavigableString` subclass that represents embedded CSS "
"stylesheets; that is, any strings found inside a ``<style>`` tag during "
"document parsing."
msgstr ""
"Подкласс :py:class:`NavigableString`, который представляет встроенные "
"таблицы стилей CSS, то есть любые строки, найденные при разборе документа"
" внутри тега ``<style>``."

#: ../../bs4ru.rst:561
msgid ""
"A :py:class:`NavigableString` subclass that represents embedded "
"Javascript; that is, any strings found inside a ``<script>`` tag during "
"document parsing."
msgstr ""
"Подкласс :py:class:`NavigableString`, представляющий встроенный "
"Javascript, то есть любые строки, найденные при разборе документа внутри "
"тега ``<script>``."

#: ../../bs4ru.rst:567
msgid ""
"A :py:class:`NavigableString` subclass that represents embedded HTML "
"templates; that is, any strings found inside a ``<template>`` tag during "
"document parsing."
msgstr ""
"Подкласс :py:class:`NavigableString`, представляющий встроенные шаблоны "
"HTML, то есть любые строки, найденные при разборе документа внутри тега "
"``<template>``."

#: ../../bs4ru.rst:572
msgid "For XML documents"
msgstr "Для документов XML"

#: ../../bs4ru.rst:574
msgid ""
"Beautiful Soup defines some :py:class:`NavigableString` classes for "
"holding special types of strings that can be found in XML documents. Like"
" :py:class:`Comment`, these classes are subclasses of "
":py:class:`NavigableString` that add something extra to the string on "
"output."
msgstr ""
"Beautiful Soup определяет несколько классов :py:class:`NavigableString` "
"для хранения специальных типов строк, которые можно найти в "
"XML-документах. Как и :py:class:`Comment`, эти классы являются "
"подклассами :py:class:`NavigableString`, которые добавляют что-то в "
"дополнение к выводимой строке."

#: ../../bs4ru.rst:582
msgid ""
"A :py:class:`NavigableString` subclass representing the `declaration "
"<https://www.w3.org/TR/REC-xml/#sec-prolog-dtd>`_ at the beginning of an "
"XML document."
msgstr ""
"Подкласс :py:class:`NavigableString`, представляющий `объявление "
"<https://www.w3.org/TR/REC-xml/#sec-prolog-dtd>`_ в начале XML-документа."

#: ../../bs4ru.rst:588
msgid ""
"A :py:class:`NavigableString` subclass representing the `document type "
"declaration <https://www.w3.org/TR/REC-xml/#dt-doctype>`_ which may be "
"found near the beginning of an XML document."
msgstr ""
"Подкласс :py:class:`NavigableString`, представляющий `объявление типа "
"документа <https://www.w3.org/TR/REC-xml/#dt-doctype>`_, которое можно "
"найти в начале XML-документа."

#: ../../bs4ru.rst:594
msgid ""
"A :py:class:`NavigableString` subclass that represents a `CData section "
"<https://www.w3.org/TR/REC-xml/#sec-cdata-sect>`_."
msgstr ""
"Подкласс :py:class:`NavigableString`, который представляет `раздел CData "
"<https://www.w3.org/TR/REC-xml/#sec-cdata-sect>`_."

#: ../../bs4ru.rst:598
msgid ""
"A :py:class:`NavigableString` subclass that represents the contents of an"
" `XML processing instruction <https://www.w3.org/TR/REC-xml/#sec-pi>`_."
msgstr ""
"Подкласс :py:class:`NavigableString`, который представляет содержимое "
"`инструкции обработки XML <https://www.w3.org/TR/REC-xml/#sec-pi>`_."

#: ../../bs4ru.rst:602
msgid "Navigating the tree"
msgstr "Навигация по дереву "

#: ../../bs4ru.rst:604
msgid "Here's the \"Three sisters\" HTML document again::"
msgstr "Вернемся к HTML-документу с фрагментом из «Алисы в стране чудес»:: "

#: ../../bs4ru.rst:623
msgid ""
"I'll use this as an example to show you how to move from one part of a "
"document to another."
msgstr ""
"Я буду использовать его в качестве примера, чтобы показать, как перейти "
"от одной части документа к другой. "

#: ../../bs4ru.rst:627
msgid "Going down"
msgstr "Проход сверху вниз "

#: ../../bs4ru.rst:629
msgid ""
"Tags may contain strings and more tags. These elements are the tag's "
"*children*. Beautiful Soup provides a lot of different attributes for "
"navigating and iterating over a tag's children."
msgstr ""
"Теги могут содержать строки и другие теги. Эти элементы являются "
"дочерними (*children*) для тега. Beautiful Soup предоставляет множество "
"различных атрибутов для навигации и перебора дочерних элементов. "

#: ../../bs4ru.rst:633
msgid ""
"Note that Beautiful Soup strings don't support any of these attributes, "
"because a string can't have children."
msgstr ""
"Обратите внимание, что строки Beautiful Soup не поддерживают ни один из "
"этих атрибутов, потому что строка не может иметь дочерних элементов. "

#: ../../bs4ru.rst:637
msgid "Navigating using tag names"
msgstr "Навигация с использованием имен тегов "

#: ../../bs4ru.rst:639
msgid ""
"The simplest way to navigate the parse tree is to find a tag by name. To "
"do this, you can use the ``find()`` method::"
msgstr ""
"Самый простой способ навигации по дереву разбора — найти тег по имени. "
"Для этого вы можете использовать метод ``find()``::"

#: ../../bs4ru.rst:645
msgid ""
"For convenience, just saying the name of the tag you want is equivalent "
"to ``find()`` (if no built-in attribute has that name). If you want the "
"<head> tag, just say ``soup.head``::"
msgstr ""
"Для удобства простое использование имени нужного тега эквивалентно вызову"
" ``find()`` (если ни один встроенный атрибут не имеет такого имени). Если"
" вам нужен тег <head>, просто используйте ``soup.head``::"

#: ../../bs4ru.rst:655
msgid ""
"You can use this trick again and again to zoom in on a certain part of "
"the parse tree. This code gets the first <b> tag beneath the <body> tag::"
msgstr ""
"Вы можете повторять этот трюк многократно, чтобы подробнее рассмотреть "
"определенную часть дерева разбора. Следующий код извлекает первый тег <b>"
" внутри тега <body>:: "

#: ../../bs4ru.rst:661
msgid ""
"``find()`` (and its convenience equivalent) gives you only the *first* "
"tag by that name::"
msgstr ""
"``find()`` (и его удобный эквивалент) дает вам только *первый* тег с "
"таким именем::"

#: ../../bs4ru.rst:667
msgid "If you need to get *all* the <a> tags, you can use ``find_all()``::"
msgstr ""
"Если вам нужно получить *все* теги <a>, вы можете использовать "
"``find_all()``::"

#: ../../bs4ru.rst:674
msgid ""
"For more complicated tasks, such as pattern-matching and filtering, you "
"can use the methods described in `Searching the tree`_."
msgstr ""
"Для более сложных задач, таких как сопоставление с образцом и фильтрация,"
" вы можете использовать методы, описанные в разделе `Поиск по дереву`_."

#: ../../bs4ru.rst:678
msgid "``.contents`` and ``.children``"
msgstr "``.contents`` и ``.children`` "

#: ../../bs4ru.rst:680
msgid "A tag's children are available in a list called ``.contents``::"
msgstr "Дочерние элементы доступны в списке под названием ``.contents``:: "

#: ../../bs4ru.rst:695
msgid ""
"The :py:class:`BeautifulSoup` object itself has children. In this case, "
"the <html> tag is the child of the :py:class:`BeautifulSoup` object.::"
msgstr ""
"Сам объект :py:class:`BeautifulSoup` имеет дочерние элементы. В этом "
"случае тег <html> является дочерним для объекта "
":py:class:`BeautifulSoup`:: "

#: ../../bs4ru.rst:703
msgid "A string does not have ``.contents``, because it can't contain anything::"
msgstr "У строки нет ``.contents``, потому что она не может содержать ничего:: "

#: ../../bs4ru.rst:710
msgid ""
"Instead of getting them as a list, you can iterate over a tag's children "
"using the ``.children`` generator::"
msgstr ""
"Вместо того, чтобы получать дочерние элементы в виде списка, вы можете "
"перебирать их с помощью генератора ``.children``:: "

#: ../../bs4ru.rst:717
msgid ""
"If you want to modify a tag's children, use the methods described in "
"`Modifying the tree`_. Don't modify the the ``.contents`` list directly: "
"that can lead to problems that are subtle and difficult to spot."
msgstr ""
"Если вы хотите изменить дочерние элементы тега, используйте методы, "
"описанные в разделе `Изменение дерева`_. Не изменяйте список "
"``.contents`` напрямую: это может привести к неуловимым проблемам, "
"которые трудно обнаружить.   "

#: ../../bs4ru.rst:724
msgid "``.descendants``"
msgstr "``.descendants`` "

#: ../../bs4ru.rst:726
msgid ""
"The ``.contents`` and ``.children`` attributes consider only a tag's "
"*direct* children. For instance, the <head> tag has a single direct "
"child—the <title> tag::"
msgstr ""
"Атрибуты ``.contents`` и ``.children`` применяются только в отношении "
"*непосредственных* дочерних элементов тега. Например, тег <head> имеет "
"только один непосредственный дочерний тег <title>:: "

#: ../../bs4ru.rst:733
msgid ""
"But the <title> tag itself has a child: the string \"The Dormouse's "
"story\". There's a sense in which that string is also a child of the "
"<head> tag. The ``.descendants`` attribute lets you iterate over *all* of"
" a tag's children, recursively: its direct children, the children of its "
"direct children, and so on::"
msgstr ""
"Но у самого тега <title> есть дочерний элемент: строка \"The Dormouse's "
"story\". В некотором смысле эта строка также является дочерним элементом "
"тега <head>. Атрибут ``.descendants`` позволяет перебирать *все* дочерние"
" элементы тега рекурсивно: его непосредственные дочерние элементы, "
"дочерние элементы дочерних элементов и так далее:: "

#: ../../bs4ru.rst:744
msgid ""
"The <head> tag has only one child, but it has two descendants: the "
"<title> tag and the <title> tag's child. The :py:class:`BeautifulSoup` "
"object only has one direct child (the <html> tag), but it has a whole lot"
" of descendants::"
msgstr ""
"У тега <head> есть только один дочерний элемент, но при этом у него два "
"потомка: тег <title> и его дочерний элемент. У объекта "
":py:class:`BeautifulSoup` только один прямой дочерний элемент (тег "
"<html>), зато множество потомков:: "

#: ../../bs4ru.rst:757
msgid "``.string``"
msgstr "``.string`` "

#: ../../bs4ru.rst:759
msgid ""
"If a tag has only one child, and that child is a "
":py:class:`NavigableString`, the child is made available as ``.string``::"
msgstr ""
"Если у тега есть только один дочерний элемент, и это "
":py:class:`NavigableString`, его можно получить через ``.string``:: "

#: ../../bs4ru.rst:765
msgid ""
"If a tag's only child is another tag, and *that* tag has a ``.string``, "
"then the parent tag is considered to have the same ``.string`` as its "
"child::"
msgstr ""
"Если единственным дочерним элементом тега является другой тег, и у этого "
"*другого* тега есть строка ``.string``, то считается, что родительский "
"тег содержит ту же строку ``.string``, что и дочерний тег:: "

#: ../../bs4ru.rst:775
msgid ""
"If a tag contains more than one thing, then it's not clear what "
"``.string`` should refer to, so ``.string`` is defined to be ``None``::"
msgstr ""
"Если тег содержит больше чем один элемент, то становится неясным, какая "
"из строк ``.string`` относится и к родительскому тегу, поэтому "
"``.string`` родительского тега имеет значение ``None``:: "

#: ../../bs4ru.rst:785
msgid "``.strings`` and ``stripped_strings``"
msgstr "``.strings`` и ``.stripped_strings`` "

#: ../../bs4ru.rst:787
msgid ""
"If there's more than one thing inside a tag, you can still look at just "
"the strings. Use the ``.strings`` generator to see all descendant "
"strings::"
msgstr ""
"Если внутри тега есть более одного элемента, вы все равно можете "
"посмотреть только на строки. Используйте генератор ``.strings``, чтобы "
"увидеть все дочерние строки:: "

#: ../../bs4ru.rst:810
msgid ""
"Newlines and spaces that separate tags are also strings. You can remove "
"extra whitespace by using the ``.stripped_strings`` generator instead::"
msgstr ""
"Символы новой строки и пробелы, разделяющие теги, также являются "
"строками. Вы можете удалить лишние пробелы, используя генератор "
"``.stripped_strings``:: "

#: ../../bs4ru.rst:826
msgid ""
"Here, strings consisting entirely of whitespace are ignored, and "
"whitespace at the beginning and end of strings is removed."
msgstr ""
"Здесь строки, состоящие исключительно из пробелов, игнорируются, а "
"пробелы в начале и конце строк удаляются. "

#: ../../bs4ru.rst:830
msgid "Going up"
msgstr "Проход снизу вверх "

#: ../../bs4ru.rst:832
msgid ""
"Continuing the \"family tree\" analogy, every tag and every string has a "
"*parent*: the tag that contains it."
msgstr ""
"В продолжение аналогии с «семейным деревом», каждый тег и каждая строка "
"имеет родителя (*parent*): тег, который его содержит. "

#: ../../bs4ru.rst:838
msgid "``.parent``"
msgstr "``.parent`` "

#: ../../bs4ru.rst:840
msgid ""
"You can access an element's parent with the ``.parent`` attribute. In the"
" example \"three sisters\" document, the <head> tag is the parent of the "
"<title> tag::"
msgstr ""
"Вы можете получить доступ к родительскому элементу с помощью атрибута "
"``.parent``. В примере документа с фрагментом из «Алисы в стране чудес» "
"тег <head> является родительским для тега <title>:: "

#: ../../bs4ru.rst:850
msgid "The title string itself has a parent: the <title> tag that contains it::"
msgstr "Строка заголовка сама имеет родителя: тег <title>, содержащий ее:: "

#: ../../bs4ru.rst:856
msgid ""
"The parent of a top-level tag like <html> is the "
":py:class:`BeautifulSoup` object itself::"
msgstr ""
"Родительским элементом тега верхнего уровня, такого как <html>, является "
"сам объект :py:class:`BeautifulSoup`:: "

#: ../../bs4ru.rst:863
msgid ""
"And the ``.parent`` of a :py:class:`BeautifulSoup` object is defined as "
"None::"
msgstr "И ``.parent`` объекта :py:class:`BeautifulSoup` определяется как None:: "

#: ../../bs4ru.rst:871
msgid "``.parents``"
msgstr "``.parents`` "

#: ../../bs4ru.rst:873
msgid ""
"You can iterate over all of an element's parents with ``.parents``. This "
"example uses ``.parents`` to travel from an <a> tag buried deep within "
"the document, to the very top of the document::"
msgstr ""
"Вы можете перебрать всех родителей элемента с помощью ``.parents``. В "
"следующем примере ``.parents`` используется для перемещения от тега <a>, "
"закопанного глубоко внутри документа, до самого верха документа:: "

#: ../../bs4ru.rst:888
msgid "``.self_and_parents``"
msgstr "``.self_and_parents``"

#: ../../bs4ru.rst:890
msgid ""
"The ``.self_and_parents`` generator is a variant of ``.parents`` which "
"gives you the entire ancestry of an element, including the element "
"itself::"
msgstr ""
"Генератор ``.self_and_parents`` является вариантом ``.parents``, он дает вам полную информацию о происхождении элемента, включая сам элемент::"

#: ../../bs4ru.rst:904
msgid "Going sideways"
msgstr "Перемещение вбок "

#: ../../bs4ru.rst:906
msgid "Consider a simple document like this::"
msgstr "Рассмотрим простой документ:: "

#: ../../bs4ru.rst:919
msgid ""
"The <b> tag and the <c> tag are at the same level: they're both direct "
"children of the same tag. We call them *siblings*. When a document is "
"pretty-printed, siblings show up at the same indentation level. You can "
"also use this relationship in the code you write."
msgstr ""
"Тег <b> и тег <c> находятся на одном уровне: они оба непосредственные "
"дочерние элементы одного и того же тега. Мы называем их *одноуровневые*. "
"Когда документ красиво отформатирован, одноуровневые элементы выводятся с"
" одинаковым  отступом. Вы также можете использовать это отношение в "
"написанном вами коде. "

#: ../../bs4ru.rst:925
msgid "``.next_sibling`` and ``.previous_sibling``"
msgstr "``.next_sibling`` и ``.previous_sibling`` "

#: ../../bs4ru.rst:927
msgid ""
"You can use ``.next_sibling`` and ``.previous_sibling`` to navigate "
"between page elements that are on the same level of the parse tree::"
msgstr ""
"Вы можете использовать ``.next_sibling`` и ``.previous_sibling`` для "
"навигации между элементами страницы, которые находятся на одном уровне "
"дерева разбора:: "

#: ../../bs4ru.rst:936
msgid ""
"The <b> tag has a ``.next_sibling``, but no ``.previous_sibling``, "
"because there's nothing before the <b> tag *on the same level of the "
"tree*. For the same reason, the <c> tag has a ``.previous_sibling`` but "
"no ``.next_sibling``::"
msgstr ""
"У тега <b> есть ``.next_sibling``, но нет ``.previous_sibling``, потому "
"что нет ничего до тега <b> *на том же уровне дерева*. По той же причине у"
" тега <c> есть ``.previous_sibling``, но нет ``.next_sibling``:: "

#: ../../bs4ru.rst:946
msgid ""
"The strings \"text1\" and \"text2\" are *not* siblings, because they "
"don't have the same parent::"
msgstr ""
"Строки \"text1\" и \"text2\" *не являются* одноуровневыми, потому что они"
" не имеют общего родителя:: "

#: ../../bs4ru.rst:955
msgid ""
"In real documents, the ``.next_sibling`` or ``.previous_sibling`` of a "
"tag will usually be a string containing whitespace. Going back to the "
"\"three sisters\" document::"
msgstr ""
"В реальных документах ``.next_sibling`` или ``.previous_sibling`` тега "
"обычно будет строкой, содержащей пробелы. Возвращаясь к фрагменту из "
"«Алисы в стране чудес»:: "

#: ../../bs4ru.rst:963
msgid ""
"You might think that the ``.next_sibling`` of the first <a> tag would be "
"the second <a> tag. But actually, it's a string: the comma and newline "
"that separate the first <a> tag from the second::"
msgstr ""
"Вы можете подумать, что ``.next_sibling`` первого тега <a> должен быть "
"второй тег <a>. Но на самом деле это строка: запятая и перевод строки, "
"отделяющий первый тег <a> от второго:: "

#: ../../bs4ru.rst:974
msgid "The second <a> tag is then the ``.next_sibling`` of the comma string::"
msgstr "Второй тег <a> на самом деле является ``.next_sibling`` запятой :: "

#: ../../bs4ru.rst:982
msgid "``.next_siblings`` and ``.previous_siblings``"
msgstr "``.next_siblings`` и ``.previous_siblings`` "

#: ../../bs4ru.rst:984
msgid ""
"You can iterate over a tag's siblings with ``.next_siblings`` or "
"``.previous_siblings``::"
msgstr ""
"Вы можете перебрать одноуровневые элементы данного тега с помощью "
"``.next_siblings`` или ``.previous_siblings``:: "

#: ../../bs4ru.rst:1003
msgid ""
"(If the argument syntax to find tags by their attribute value is "
"unfamiliar, don't worry; this is covered later in :ref:`The keyword "
"arguments <kwargs>`.)"
msgstr ""
"(Если синтаксис аргументов для поиска тегов по значению их атрибута вам "
"незнаком, не волнуйтесь; это описано позже, в разделе :ref:`Именованные "
"аргументы <kwargs>`.)"

#: ../../bs4ru.rst:1007
msgid "Going back and forth"
msgstr "Проход вперед и назад "

#: ../../bs4ru.rst:1009
msgid "Take a look at the beginning of the \"three sisters\" document::"
msgstr "Взгляните на начало фрагмента из «Алисы в стране чудес»:: "

#: ../../bs4ru.rst:1016
msgid ""
"An HTML parser takes this string of characters and turns it into a series"
" of events: \"open an <html> tag\", \"open a <head> tag\", \"open a "
"<title> tag\", \"add a string\", \"close the <title> tag\", \"open a <p> "
"tag\", and so on. The order in which the opening tags and strings are "
"encountered is called *document order*. Beautiful Soup offers tools for "
"searching a document's elements in document order."
msgstr ""
"HTML-парсер берет эту строку символов и превращает ее в серию событий: "
"\"открыть тег <html>\", \"открыть тег <head>\", \"открыть тег <html>\", "
"\"добавить строку\", \"закрыть тег <title>\", \"открыть тег <p>\" и так "
"далее.  Порядок, в котором встречаются открывающие теги и строки, "
"называется *порядком документа*. Beautiful Soup предлагает инструменты "
"для поиска элементов документа в порядке документа."

#: ../../bs4ru.rst:1026
msgid "``.next_element`` and ``.previous_element``"
msgstr "``.next_element`` и ``.previous_element`` "

#: ../../bs4ru.rst:1028
msgid ""
"The ``.next_element`` attribute of a string or tag points to whatever was"
" parsed immediately after the opening of the current tag or after the "
"current string. It might be the same as ``.next_sibling``, but it's "
"usually drastically different."
msgstr ""
"Атрибут ``.next_element`` строки или тега указывает на то, что было "
"разобрано непосредственно после открытия текущего тега или после текущей "
"строки. Это может оказаться тем же, что и ``.next_sibling``, но обычно "
"результат резко отличается. "

#: ../../bs4ru.rst:1033
msgid ""
"Here's the final <a> tag in the \"three sisters\" document. Its "
"``.next_sibling`` is a string: the conclusion of the sentence that was "
"interrupted by the start of the <a> tag::"
msgstr ""
"Возьмем последний тег <a> в фрагменте из «Алисы в стране чудес». Его "
"``.next_sibling`` является строкой: конец предложения, которое было "
"прервано началом тега <a>:: "

#: ../../bs4ru.rst:1044
msgid ""
"But the ``.next_element`` of that <a> tag, the thing that was parsed "
"immediately after the <a> tag, is *not* the rest of that sentence: it's "
"the string \"Tillie\" inside it::"
msgstr ""
"Но ``.next_element`` этого тега <a> — это то, что было разобрано сразу "
"после тега <a>, *не* остальная часть этого предложения: это строка "
"\"Tillie\" внутри тега:: "

#: ../../bs4ru.rst:1051
msgid ""
"That's because in the original markup, the word \"Tillie\" appeared "
"before that semicolon. The parser encountered an <a> tag, then the word "
"\"Tillie\", then the closing </a> tag, then the semicolon and rest of the"
" sentence. The semicolon is on the same level as the <a> tag, but the "
"word \"Tillie\" was encountered first."
msgstr ""
"Это потому, что в оригинальной разметке слово «Tillie» появилось перед "
"точкой с запятой. Парсер обнаружил тег <a>, затем слово «Tillie», затем "
"закрывающий тег </a>, затем точку с запятой и оставшуюся часть "
"предложения. Точка с запятой находится на том же уровне, что и тег <a>, "
"но слово «Tillie» встретилось первым. "

#: ../../bs4ru.rst:1057
msgid ""
"The ``.previous_element`` attribute is the exact opposite of "
"``.next_element``. It points to the opening tag or string that was parsed"
" immediately before this one::"
msgstr ""
"Атрибут ``.previous_element`` является полной противоположностью "
"``.next_element``. Он указывает на открывающий тег или строку, которые "
"встретились при разборе непосредственно перед текущим элементом:: "

#: ../../bs4ru.rst:1067
msgid "``.next_elements`` and ``.previous_elements``"
msgstr "``.next_elements`` и ``.previous_elements`` "

#: ../../bs4ru.rst:1069
msgid ""
"You should get the idea by now. You can use these iterators to move "
"forward or backward in the document as it was parsed::"
msgstr ""
"Вы уже должны были уловить идею. Вы можете использовать их для "
"перемещения вперед или назад по документу, в том порядке, в каком он был "
"разобран парсером:: "

#: ../../bs4ru.rst:1082
msgid "Searching the tree"
msgstr "Поиск по дереву"

#: ../../bs4ru.rst:1084
msgid ""
"Beautiful Soup defines a lot of methods for searching the parse tree, but"
" they're all very similar. I'm going to spend a lot of time explaining "
"the two most popular methods: ``find()`` and ``find_all()``. The other "
"methods take almost exactly the same arguments, so I'll just cover them "
"briefly."
msgstr ""
"Beautiful Soup определяет множество методов поиска по дереву разбора, но "
"они все очень похожи. Я буду долго объяснять, как работают два самых "
"популярных метода: ``find()`` и ``find_all()``. Прочие методы принимают "
"практически те же самые аргументы, поэтому я расскажу о них вкратце. "

#: ../../bs4ru.rst:1090
msgid "Once again, I'll be using the \"three sisters\" document as an example::"
msgstr ""
"И опять, я буду использовать фрагмент из «Алисы в стране чудес» в "
"качестве примера:: "

#: ../../bs4ru.rst:1109
msgid ""
"By passing in a filter to a method like ``find_all()``, you can zoom in "
"on the parts of the document you're interested in."
msgstr ""
"Передав фильтр в метод типа ``find_all()``, вы можете углубиться в "
"интересующие вас части документа. "

#: ../../bs4ru.rst:1113
msgid "Kinds of filters"
msgstr "Виды фильтров "

#: ../../bs4ru.rst:1115
msgid ""
"Before talking in detail about ``find_all()`` and similar methods, I want"
" to show examples of different filters you can pass into these methods. "
"These filters show up again and again, throughout the search API. You can"
" use them to filter based on a tag's name, on its attributes, on the text"
" of a string, or on some combination of these."
msgstr ""
"Прежде чем подробно рассказывать о ``find_all()`` и подобных методах, я "
"хочу показать примеры различных фильтров, которые вы можете передать в "
"эти методы. Эти фильтры появляются снова и снова в поисковом API. Вы "
"можете использовать их для фильтрации по имени тега, по его атрибутам, по"
" тексту строки или по некоторой их комбинации. "

#: ../../bs4ru.rst:1125
msgid "A string"
msgstr "Строка "

#: ../../bs4ru.rst:1127
msgid ""
"The simplest filter is a string. Pass a string to a search method and "
"Beautiful Soup will perform a tag-name match against that exact string. "
"This code finds all the <b> tags in the document::"
msgstr ""
"Самый простой фильтр — это строка. Передайте строку в метод поиска, и "
"Beautiful Soup выполнит поиск соответствия имени тега этой строке. "
"Следующий код находит все теги <b> в документе:: "

#: ../../bs4ru.rst:1134
msgid ""
"If you pass in a byte string, Beautiful Soup will assume the string is "
"encoded as UTF-8. You can avoid this by passing in a Unicode string "
"instead."
msgstr ""
"Если вы передадите байтовую строку, Beautiful Soup будет считать, что "
"строка кодируется в UTF-8. Вы можете избежать этого, передав вместо нее "
"строку Unicode. "

#: ../../bs4ru.rst:1140
msgid "A regular expression"
msgstr "Регулярное выражение "

#: ../../bs4ru.rst:1142
msgid ""
"If you pass in a regular expression object, Beautiful Soup will filter "
"against that regular expression using its ``search()`` method. This code "
"finds all the tags whose names start with the letter \"b\"; in this case,"
" the <body> tag and the <b> tag::"
msgstr ""
"Если вы передадите объект с регулярным выражением, Beautiful Soup "
"отфильтрует результаты в соответствии с этим регулярным выражением, "
"используя его метод ``search()``. Следующий код находит все теги, имена "
"которых начинаются с буквы \"b\"; в нашем случае это теги <body> и <b>:: "

#: ../../bs4ru.rst:1153
msgid "This code finds all the tags whose names contain the letter 't'::"
msgstr "Этот код находит все теги, имена которых содержат букву \"t\":: "

#: ../../bs4ru.rst:1163
msgid "``True``"
msgstr "``True`` "

#: ../../bs4ru.rst:1165
msgid ""
"The value ``True`` matches every tag it can. This code finds *all* the "
"tags in the document, but none of the text strings::"
msgstr ""
"Значение ``True`` соответствует любому тегу. Следующий код находит *все* "
"теги в документе, но не текстовые строки:: "

#: ../../bs4ru.rst:1185
msgid "A function"
msgstr "Функция "

#: ../../bs4ru.rst:1187
msgid ""
"If none of the other matches work for you, define a function that takes "
"an element as its only argument. The function should return ``True`` if "
"the argument matches, and ``False`` otherwise."
msgstr ""
"Если ничто из перечисленного вам не подходит, определите функцию, которая"
" принимает элемент в качестве единственного аргумента. Функция должна "
"вернуть ``True``, если аргумент подходит, и ``False``, если нет. "

#: ../../bs4ru.rst:1191
msgid ""
"Here's a function that returns ``True`` if a tag defines the \"class\" "
"attribute but doesn't define the \"id\" attribute::"
msgstr ""
"Вот функция, которая возвращает ``True``, если в теге определен атрибут "
"\"class\", но не определен атрибут \"id\":: "

#: ../../bs4ru.rst:1197
msgid ""
"Pass this function into ``find_all()`` and you'll pick up all the <p> "
"tags::"
msgstr "Передайте эту функцию в ``find_all()``, и вы получите все теги <p>:: "

#: ../../bs4ru.rst:1205
msgid ""
"This function picks up only the <p> tags. It doesn't pick up the <a> "
"tags, because those tags define both \"class\" and \"id\". It doesn't "
"pick up tags like <html> and <title>, because those tags don't define "
"\"class\"."
msgstr ""
"Эта функция выбирает только теги <p>. Она не выбирает теги <a>, поскольку"
" в них определены и атрибут \"class\" , и атрибут \"id\". Она не выбирает"
" теги вроде <html> и <title>, потому что в них не определен атрибут "
"\"class\". "

#: ../../bs4ru.rst:1210
msgid ""
"The function can be as complicated as you need it to be. Here's a "
"function that returns ``True`` if a tag is surrounded by string objects::"
msgstr ""
"Функция может быть настолько сложной, насколько вам нужно. Вот функция, "
"которая возвращает ``True``, если тег окружен строковыми объектами:: "

#: ../../bs4ru.rst:1231
msgid "A list"
msgstr "Список "

#: ../../bs4ru.rst:1233
msgid ""
"If you pass in a list, Beautiful Soup will look for a match against *any*"
" string, regular expression, or function in that list. This code finds "
"all the <a> tags *and* all the <b> tags::"
msgstr ""
"Если вы передадите список, Beautiful Soup будет искать совпадение строк с"
" *любой* строкой, регулярным выражением или функцией из этого списка. "
"Следующий код находит все теги <a> *и* все теги <b>:: "

#: ../../bs4ru.rst:1243
msgid "Now we're ready to look at the search methods in detail."
msgstr "Теперь мы готовы подробно рассмотреть методы поиска. "

#: ../../bs4ru.rst:1246
msgid "``find_all()``"
msgstr "``find_all()`` "

#: ../../bs4ru.rst:1248
msgid ""
"Method signature: find_all(:ref:`name <name>`, :ref:`attrs <attrs>`, "
":ref:`recursive <recursive>`, :ref:`string <string>`, :ref:`limit "
"<limit>`, :ref:`**kwargs <kwargs>`)"
msgstr ""
"Сигнатура метода: find_all(:ref:`name <name>`, :ref:`attrs <attrs>`, "
":ref:`recursive <recursive>`, :ref:`string <string>`, :ref:`limit "
"<limit>`, :ref:`**kwargs <kwargs>`) "

#: ../../bs4ru.rst:1251
msgid ""
"The ``find_all()`` method looks through a tag's descendants and retrieves"
" *all* descendants that match your filters. I gave several examples in "
"`Kinds of filters`_, but here are a few more::"
msgstr ""
"Метод ``find_all()`` просматривает потомков тега и извлекает *всех* "
"потомков, которые соответствую вашим фильтрам. Я привел несколько "
"примеров в разделе `Виды фильтров`_, а вот еще несколько:: "

#: ../../bs4ru.rst:1273
msgid ""
"Some of these should look familiar, but others are new. What does it mean"
" to pass in a value for ``string``, or ``id``? Why does ``find_all(\"p\","
" \"title\")`` find a <p> tag with the CSS class \"title\"? Let's look at "
"the arguments to ``find_all()``."
msgstr ""
"Кое-что из этого нам уже знакомо, но есть и новое. Что означает передача "
"значения для ``string`` или ``id``? Почему ``find_all (\"p\", "
"\"title\")`` находит тег <p> с CSS-классом \"title\"? Давайте посмотрим "
"на аргументы ``find_all()``. "

#: ../../bs4ru.rst:1281
msgid "The ``name`` argument"
msgstr "Аргумент ``name`` "

#: ../../bs4ru.rst:1283
msgid ""
"Pass in a value for ``name`` and you'll tell Beautiful Soup to only "
"consider tags with certain names. Text strings will be ignored, as will "
"tags whose names that don't match."
msgstr ""
"Передайте значение для аргумента ``name``, и вы скажете Beautiful Soup "
"рассматривать только теги с определенными именами. Текстовые строки будут"
" игнорироваться, так же как и теги, имена которых не соответствуют "
"заданным. "

#: ../../bs4ru.rst:1287
msgid "This is the simplest usage::"
msgstr "Вот простейший пример использования:: "

#: ../../bs4ru.rst:1292
msgid ""
"Recall from `Kinds of filters`_ that the value to ``name`` can be `a "
"string`_, `a regular expression`_, `a list`_, `a function`_, or `the "
"value True`_."
msgstr ""
"В разделе  `Виды фильтров`_ говорилось, что значением ``name`` может быть"
" `строка`_, `регулярное выражение`_, `список`_, `функция`_ или `True`_. "

#: ../../bs4ru.rst:1299
msgid "The keyword arguments"
msgstr "Именованные аргументы "

#: ../../bs4ru.rst:1301
msgid ""
"Any keyword argument that's not recognized will be turned into a filter "
"that matches tags by their attributes."
msgstr ""
"Любой нераспознанный именованный аргумент будет преобразован в фильтр, "
"который сопоставляет теги по их атрибутам."

#: ../../bs4ru.rst:1304
msgid ""
"If you pass in a value for an argument called ``id``, Beautiful Soup will"
" filter against each tag's 'id' attribute value::"
msgstr ""
"Если вы передадите значение для аргумента ``id``, Beautiful Soup "
"отфильтрует по атрибуту \"id\" каждого тега::"

#: ../../bs4ru.rst:1310
msgid ""
"Just as with tags, you can filter an attribute based on `a string`_, `a "
"regular expression`_, `a list`_, `a function`_, or `the value True`_."
msgstr ""
"Как и в случае с тегами, для фильтрации по атрибуту может использоваться "
"`строка`_, `регулярное выражение`_, `список`_, `функция`_ или значение "
"`True`_. "

#: ../../bs4ru.rst:1313
msgid ""
"If you pass in a regular expression object for ``href``, Beautiful Soup "
"will pattern-match against each tag's 'href' attribute value::"
msgstr ""
"Если вы передадите значение для ``href``, Beautiful Soup будет "
"сопоставлять шаблон с атрибутом \"href\" каждого тега:: "

#: ../../bs4ru.rst:1319
msgid ""
"The value ``True`` matches every tag that defines the attribute. This "
"code finds *all* tags with an ``id`` attribute::"
msgstr ""
"Значение ``True`` соответствует любому тегу с определенным атрибутом. "
"Следующий код находит в документе *все* теги с атрибутом ``id``::"

#: ../../bs4ru.rst:1327
msgid ""
"For more complex matches, you can define a function that takes an "
"attribute value as its only argument. The function should return ``True``"
" if the value matches, and ``False`` otherwise."
msgstr ""
"Для более сложных случаев вы можете определить функцию, которая принимает"
" значение атрибута в качестве единственного аргумента. Функция должна "
"вернуть ``True``, если значение подходит, и ``False``, если нет. "

#: ../../bs4ru.rst:1331
msgid ""
"Here's a function that finds all ``a`` tags whose ``href`` attribute "
"*does not* match a regular expression::"
msgstr ""
"Вот функция, которая находит все теги ``a``, чей атрибут ``href`` *не* "
"соответствует регулярному выражению::"

#: ../../bs4ru.rst:1342
msgid ""
"If you pass in a list for an argument, Beautiful Soup will look for an "
"attribute-value match against *any* string, regular expression, or "
"function in that list. This code finds the first and last link::"
msgstr ""
"Если вы передадите список, Beautiful Soup будет искать совпадение строк с"
" *любой* строкой, регулярным выражением или функцией из этого списка. "
"Следующий код находит все теги <a> `и` все теги <b>:: "

#: ../../bs4ru.rst:1350
msgid ""
"You can filter against multiple attributes at once by passing multiple "
"keyword arguments::"
msgstr ""
"Вы можете отфильтровать по нескольким атрибутам одновременно, передав "
"более одного именованного аргумента:: "

#: ../../bs4ru.rst:1356
msgid ""
"Some attributes, like the data-* attributes in HTML 5, have names that "
"can't be used as the names of keyword arguments::"
msgstr ""
"Некоторые атрибуты, такие как атрибуты data-* в HTML 5, имеют имена, "
"которые нельзя использовать в качестве имен именованных аргументов:: "

#: ../../bs4ru.rst:1363
msgid ""
"You can use these attributes in searches by putting them into a "
"dictionary and passing the dictionary into ``find_all()`` as the "
"``attrs`` argument::"
msgstr ""
"Вы можете использовать эти атрибуты в поиске, поместив их в словарь и "
"передав словарь в ``find_all()`` как аргумент ``attrs``:: "

#: ../../bs4ru.rst:1370
msgid ""
"Similarly, you can't use a keyword argument to search for HTML's 'name' "
"attribute, because Beautiful Soup uses the ``name`` argument to contain "
"the name of the tag itself. Instead, you can give a value to 'name' in "
"the ``attrs`` argument::"
msgstr ""
"Сходным образом, нельзя использовать именованный аргумент для поиска в "
"HTML по элементу \"name\", потому что Beautiful Soup использует аргумент "
"``name`` для имени самого тега. Вместо этого вы можете передать элемент "
"\"name\" вместе с его значением в составе аргумента ``attrs``:: "

#: ../../bs4ru.rst:1384
msgid "Searching by CSS class"
msgstr "Поиск по классу CSS "

#: ../../bs4ru.rst:1386
msgid ""
"It's very useful to search for a tag that has a certain CSS class, but "
"the name of the CSS attribute, \"class\", is a reserved word in Python. "
"Using ``class`` as a keyword argument will give you a syntax error. As of"
" Beautiful Soup 4.1.2, you can search by CSS class using the keyword "
"argument ``class_``::"
msgstr ""
"Очень удобно искать тег с определенным классом CSS, но имя атрибута CSS, "
"\"class\", является зарезервированным словом в Python. Использование "
"``class`` в качестве именованного аргумента приведет к синтаксической "
"ошибке. Начиная с Beautiful Soup 4.1.2, вы можете выполнять поиск по "
"классу CSS, используя именованный аргумент ``class_``:: "

#: ../../bs4ru.rst:1397
msgid ""
"As with any keyword argument, you can pass ``class_`` a string, a regular"
" expression, a function, or ``True``::"
msgstr ""
"Как и с любым именованным аргументом, вы можете передать в качестве "
"значения ``class_`` строку, регулярное выражение, функцию или ``True``:: "

#: ../../bs4ru.rst:1411
msgid ""
":ref:`Remember <multivalue>` that a single tag can have multiple values "
"for its \"class\" attribute. When you search for a tag that matches a "
"certain CSS class, you're matching against *any* of its CSS classes::"
msgstr ""
"Помните, что один тег может иметь :ref:`несколько значений <multivalue>` "
"для атрибута \"class\". Когда вы ищете тег, который соответствует "
"определенному классу CSS, вы ищете соответствие *любому* из его классов "
"CSS:: "

#: ../../bs4ru.rst:1423
msgid ""
"You can also search for the exact string value of the ``class`` "
"attribute::"
msgstr "Можно искать точное строковое значение атрибута ``class``:: "

#: ../../bs4ru.rst:1428
msgid "But searching for variants of the string value won't work::"
msgstr "Но поиск вариантов строкового значения не сработает:: "

#: ../../bs4ru.rst:1433
msgid ""
"In older versions of Beautiful Soup, which don't have the ``class_`` "
"shortcut, you can use the ``attrs`` argument trick mentioned above. "
"Create a dictionary whose value for \"class\" is the string (or regular "
"expression, or whatever) you want to search for::"
msgstr ""
"В старых версиях Beautiful Soup, в которых нет ярлыка ``class_`` можно "
"использовать трюк  с аргументом ``attrs``, упомянутый выше. Создайте "
"словарь, значение которого для \"class\" является строкой (или регулярным"
" выражением, или чем угодно еще), которую вы хотите найти:: "

#: ../../bs4ru.rst:1443
msgid ""
"To search for tags that match two or more CSS classes at once, use the "
":py:meth:`Tag.select` CSS selector method :ref:`described here <css-"
"selectors>`::"
msgstr ""
"Для поиска тегов, которые соответствуют двум или более классам CSS, "
"используйте метод селекторов CSS :py:meth:`Tag.select`, :ref:`описанный тут <css-"
"selectors>`:: "

#: ../../bs4ru.rst:1452
msgid "The ``string`` argument"
msgstr "Аргумент ``string`` "

#: ../../bs4ru.rst:1454
msgid ""
"With the ``string`` argument, you can search for strings instead of tags."
" As with ``name`` and attribute keyword arguments, you can pass in `a "
"string`_, `a regular expression`_, `a function`_, `a list`_, or `the "
"value True`_. Here are some examples::"
msgstr ""
"С помощью аргумента ``string`` вы можете искать строки вместо тегов. Как "
"и в случае с ``name`` и именованными аргументами атрибута, передаваться "
"может `строка`_, `регулярное выражение`_, `список`_, `функция`_ или "
"значения `True`_. Вот несколько примеров:: "

#: ../../bs4ru.rst:1475
msgid ""
"If you use the ``string`` argument in a tag search, Beautiful Soup will "
"find all tags whose ``.string`` matches your value for ``string``. This "
"code finds the <a> tags whose ``.string`` is \"Elsie\"::"
msgstr ""
"Если вы используете аргумент ``string`` в поиске по тегу, Beautiful Soup "
"найдет все теги, в которых ``.string`` соответствует вашему значению для "
"``string``. Следующий код находит все теги <a>, у которых ``.string`` "
"равно \"Elsie\":: "

#: ../../bs4ru.rst:1482
msgid ""
"The ``string`` argument is new in Beautiful Soup 4.4.0. In earlier "
"versions it was called ``text``::"
msgstr ""
"Аргумент ``string`` — это новое в Beautiful Soup 4.4.0. В ранних версиях "
"он назывался ``text``:: "

#: ../../bs4ru.rst:1491
msgid "The ``limit`` argument"
msgstr "Аргумент ``limit`` "

#: ../../bs4ru.rst:1493
msgid ""
"``find_all()`` returns all the tags and strings that match your filters. "
"This can take a while if the document is large. If you don't need *all* "
"the results, you can pass in a number for ``limit``. This works just like"
" the LIMIT keyword in SQL. It tells Beautiful Soup to stop gathering "
"results after it's found a certain number."
msgstr ""
"``find_all()`` возвращает все теги и строки, которые соответствуют вашим "
"фильтрам. Это может занять некоторое время, если документ большой. Если "
"вам не нужны *все* результаты, вы можете указать их предельное число — "
"``limit``. Это работает так же, как ключевое слово LIMIT в SQL. Оно "
"говорит Beautiful Soup прекратить собирать результаты после того, как их "
"найдено определенное количество. "

#: ../../bs4ru.rst:1499
msgid ""
"There are three links in the \"three sisters\" document, but this code "
"only finds the first two::"
msgstr ""
"В фрагменте из «Алисы в стране чудес» есть три ссылки, но следующий код "
"находит только первые две:: "

#: ../../bs4ru.rst:1509
msgid "The ``recursive`` argument"
msgstr "Аргумент ``recursive`` "

#: ../../bs4ru.rst:1511
msgid ""
"By default, ``mytag.find_all()`` will examine all the descendants of "
"``mytag``: its children, its children's children, and so on. To consider "
"only direct children, you can pass in ``recursive=False``. See the "
"difference here::"
msgstr ""
"По умолчанию ``mytag.find_all()`` проверяет всех потомков ``mytag``: его "
"дочерние элементы, дочерние элементы дочерних элементов, и так далее. "
"Чтобы рассматривались только непосредственные потомки (дочерние "
"элементы), вы можете передать ``recursive = False``. Оцените разницу:: "

#: ../../bs4ru.rst:1521
msgid "Here's that part of the document::"
msgstr "Вот эта часть документа:: "

#: ../../bs4ru.rst:1531
msgid ""
"The <title> tag is beneath the <html> tag, but it's not *directly* "
"beneath the <html> tag: the <head> tag is in the way. Beautiful Soup "
"finds the <title> tag when it's allowed to look at all descendants of the"
" <html> tag, but when ``recursive=False`` restricts it to the <html> "
"tag's immediate children, it finds nothing."
msgstr ""
"Тег <title> находится под тегом <html>, но не *непосредственно* под тегом"
" <html>: на пути встречается тег <head>. Beautiful Soup находит тег "
"<title>, когда разрешено просматривать всех потомков тега <html>, но "
"когда ``recursive=False`` ограничивает поиск только непосредстввенно "
"дочерними элементами,  Beautiful Soup ничего не находит. "

#: ../../bs4ru.rst:1537
msgid ""
"Beautiful Soup offers a lot of tree-searching methods (covered below), "
"and they mostly take the same arguments as ``find_all()``: ``name``, "
"``attrs``, ``string``, ``limit``, and attribute keyword arguments. But "
"the ``recursive`` argument is specific to the ``find_all()`` and "
"``find()`` methods. Passing ``recursive=False`` into a method like "
"``find_parents()`` wouldn't be very useful."
msgstr ""
"Beautiful Soup предлагает множество методов поиска по дереву (они "
"рассмотрены ниже), и они в основном принимают те же аргументы, что и "
"``find_all()``: ``name``, ``attrs``, ``string``, ``limit`` и именованные "
"аргументы атрибута. Но аргумент ``recursive`` специфичен для методов "
"``find_all()`` и ``find()``. От передачи ``recursive=False`` в метод типа"
" ``find_parents()`` будет не очень много пользы. "

#: ../../bs4ru.rst:1545
msgid "Calling a tag is like calling ``find_all()``"
msgstr "Вызов тега похож на вызов ``find_all()`` "

#: ../../bs4ru.rst:1547
msgid ""
"For convenience, calling a :py:class:`BeautifulSoup` object or "
":py:class:`Tag` object as a function is equivalent to calling "
"``find_all()`` (if no built-in method has the name of the tag you're "
"looking for). These two lines of code are equivalent::"
msgstr ""
"Для удобства вызов объекта :py:class:`BeautifulSoup` или объекта "
":py:class:`Tag` как функции эквивалентен вызову ``find_all()`` (если ни "
"один встроенный метод не назван так же, как тег, который вы ищете). Эти "
"две строки кода эквивалентны::"

#: ../../bs4ru.rst:1555
msgid "These two lines are also equivalent::"
msgstr "Эти две строки также эквивалентны:: "

#: ../../bs4ru.rst:1561
msgid "``find()``"
msgstr "``find()`` "

#: ../../bs4ru.rst:1563
msgid ""
"Method signature: find(:ref:`name <name>`, :ref:`attrs <attrs>`, "
":ref:`recursive <recursive>`, :ref:`string <string>`, :ref:`**kwargs "
"<kwargs>`)"
msgstr ""
"Сигнатура метода: find(:ref:`name <name>`, :ref:`attrs <attrs>`, "
":ref:`recursive <recursive>`, :ref:`string <string>`, :ref:`**kwargs "
"<kwargs>`) "

#: ../../bs4ru.rst:1566
msgid ""
"The ``find_all()`` method scans the entire document looking for results, "
"but sometimes you only want to find one result. If you know a document "
"has only one <body> tag, it's a waste of time to scan the entire document"
" looking for more. Rather than passing in ``limit=1`` every time you call"
" ``find_all``, you can use the ``find()`` method. These two lines of code"
" are *nearly* equivalent::"
msgstr ""
"Метод ``find_all()`` сканирует весь документ в поиске всех результатов, "
"но иногда вам нужен только один. Если вы знаете, что в документе есть "
"только один тег <body>, нет смысла сканировать весь документ в поиске "
"остальных. Вместо того, чтобы передавать ``limit=1`` каждый раз, когда вы"
" вызываете ``find_all()``, используйте метод ``find()``. Эти две строки "
"кода эквивалентны:: "

#: ../../bs4ru.rst:1579
msgid ""
"The only difference is that ``find_all()`` returns a list containing the "
"single result, and ``find()`` just returns the result."
msgstr ""
"Разница лишь в том, что ``find_all()`` возвращает список, содержащий "
"единственный результат, а ``find()`` возвращает только сам результат. "

#: ../../bs4ru.rst:1582
msgid ""
"If ``find_all()`` can't find anything, it returns an empty list. If "
"``find()`` can't find anything, it returns ``None``::"
msgstr ""
"Если ``find_all()`` не может ничего найти, он возвращает пустой список. "
"Если ``find()`` не может ничего найти, он возвращает ``None``:: "

#: ../../bs4ru.rst:1588
msgid ""
"Remember the ``soup.head.title`` trick from `Navigating using tag "
"names`_? That trick works by repeatedly calling ``find()``::"
msgstr ""
"Помните трюк с ``soup.head.title`` из раздела `Навигация с использованием"
" имен тегов`_? Этот трюк работает на основе неоднократного вызова "
"``find()``:: "

#: ../../bs4ru.rst:1598
msgid "``find_parents()`` and ``find_parent()``"
msgstr "``find_parents()`` и ``find_parent()`` "

#: ../../bs4ru.rst:1600
msgid ""
"Method signature: find_parents(:ref:`name <name>`, :ref:`attrs <attrs>`, "
":ref:`string <string>`, :ref:`limit <limit>`, :ref:`**kwargs <kwargs>`)"
msgstr ""
"Сигнатура метода: find_parents(:ref:`name <name>`, :ref:`attrs <attrs>`, "
":ref:`string <string>`, :ref:`limit <limit>`, :ref:`**kwargs <kwargs>`) "

#: ../../bs4ru.rst:1602
msgid ""
"Method signature: find_parent(:ref:`name <name>`, :ref:`attrs <attrs>`, "
":ref:`string <string>`, :ref:`**kwargs <kwargs>`)"
msgstr ""
"Сигнатура метода: find_parent(:ref:`name <name>`, :ref:`attrs <attrs>`, "
":ref:`string <string>`, :ref:`**kwargs <kwargs>`) "

#: ../../bs4ru.rst:1604
msgid ""
"I spent a lot of time above covering ``find_all()`` and ``find()``. The "
"Beautiful Soup API defines ten other methods for searching the tree, but "
"don't be afraid. Five of these methods are basically the same as "
"``find_all()``, and the other five are basically the same as ``find()``. "
"The only differences are in how they move from one part of the tree to "
"another."
msgstr ""
"Я долго объяснял, как работают ``find_all()`` и ``find()``. Beautiful "
"Soup API определяет десяток других методов для поиска по дереву, но пусть"
" вас это не пугает. Пять из этих методов в целом похожи на "
"``find_all()``, а другие пять в целом похожи на ``find()``. Единственное "
"различие состоит в том, как они перемещаются от одной части дерева к "
"другой. "

#: ../../bs4ru.rst:1611
msgid ""
"First let's consider ``find_parents()`` and ``find_parent()``. Remember "
"that ``find_all()`` and ``find()`` work their way down the tree, looking "
"at tag's descendants. These methods do the opposite: they work their way "
"*up* the tree, looking at a tag's (or a string's) parents. Let's try them"
" out, starting from a string buried deep in the \"three daughters\" "
"document::"
msgstr ""
"Сначала давайте рассмотрим ``find_parents()`` и ``find_parent()``. "
"Помните, что ``find_all()`` и ``find()`` прорабатывают дерево сверху "
"вниз, просматривая теги и их потомков. ``find_parents()`` и "
"``find_parent()`` делают наоборот: они идут *снизу вверх*, рассматривая "
"родительские элементы тега или строки. Давайте испытаем их, начав со "
"строки, закопанной глубоко в фрагменте из «Алисы в стране чудес»:: "

#: ../../bs4ru.rst:1635
msgid ""
"One of the three <a> tags is the direct parent of the string in question,"
" so our search finds it. One of the three <p> tags is an indirect parent "
"(*ancestor*) of the string, and our search finds that as well. There's a "
"<p> tag with the CSS class \"title\" *somewhere* in the document, but "
"it's not one of this string's parents, so we can't find it with "
"``find_parents()``."
msgstr ""
"Один из трех тегов <a> является прямым родителем искомой строки, так что "
"наш поиск находит его. Один из трех тегов <p> является непрямым родителем"
" (*ancestor*)  строки, и наш поиск тоже его находит. Где-то в документе "
"есть тег <p> с классом CSS \"title\", но он не является родительским для "
"строки, так что мы не можем найти его с помощью ``find_parents()``. "

#: ../../bs4ru.rst:1642
msgid ""
"You may have noticed a similarity between ``find_parent()`` and "
"``find_parents()``, and the `.parent`_ and `.parents`_ attributes "
"mentioned earlier. These search methods actually use the ``.parents`` "
"attribute to iterate through all parents (unfiltered), checking each one "
"against the provided filter to see if it matches."
msgstr ""
"Вы могли заметить связь между ``find_parent()``, ``find_parents()`` и "
"атрибутами `.parent`_ и `.parents`_, упомянутыми ранее. Эти методы поиска"
" на самом деле используют атрибут ``.parents``, чтобы перебрать все "
"родительские элементы (без фильтрации), проверяя каждый из них на "
"соответствие заданному фильтру."

#: ../../bs4ru.rst:1649
msgid "``find_next_siblings()`` and ``find_next_sibling()``"
msgstr "``find_next_siblings()`` и ``find_next_sibling()`` "

#: ../../bs4ru.rst:1651
msgid ""
"Method signature: find_next_siblings(:ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, :ref:`limit <limit>`, :ref:`**kwargs "
"<kwargs>`)"
msgstr ""
"Сигнатура метода: find_next_siblings(:ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, :ref:`limit <limit>`, :ref:`**kwargs "
"<kwargs>`) "

#: ../../bs4ru.rst:1653
msgid ""
"Method signature: find_next_sibling(:ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, :ref:`**kwargs <kwargs>`)"
msgstr ""
"Сигнатура метода: find_next_sibling(:ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, :ref:`**kwargs <kwargs>`) "

#: ../../bs4ru.rst:1655
msgid ""
"These methods use :ref:`.next_siblings <sibling-generators>` to iterate "
"over the rest of an element's siblings in the tree. The "
"``find_next_siblings()`` method returns all the siblings that match, and "
"``find_next_sibling()`` returns only the first one::"
msgstr ""
"Эти методы используют :ref:`.next_siblings <sibling-generators>` для "
"перебора одноуровневых элементов для данного элемента в дереве. Метод "
"``find_next_siblings()`` возвращает все  подходящие одноуровневые "
"элементы, а ``find_next_sibling()`` возвращает только первый из них:: "

#: ../../bs4ru.rst:1673
msgid "``find_previous_siblings()`` and ``find_previous_sibling()``"
msgstr "``find_previous_siblings()`` и ``find_previous_sibling()`` "

#: ../../bs4ru.rst:1675
msgid ""
"Method signature: find_previous_siblings(:ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, :ref:`limit <limit>`, :ref:`**kwargs "
"<kwargs>`)"
msgstr ""
"Сигнатура метода: find_previous_siblings(:ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, :ref:`limit <limit>`, :ref:`**kwargs "
"<kwargs>`) "

#: ../../bs4ru.rst:1677
msgid ""
"Method signature: find_previous_sibling(:ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, :ref:`**kwargs <kwargs>`)"
msgstr ""
"Сигнатура метода: find_previous_sibling(:ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, :ref:`**kwargs <kwargs>`) "

#: ../../bs4ru.rst:1679
msgid ""
"These methods use :ref:`.previous_siblings <sibling-generators>` to "
"iterate over an element's siblings that precede it in the tree. The "
"``find_previous_siblings()`` method returns all the siblings that match, "
"and ``find_previous_sibling()`` returns only the first one::"
msgstr ""
"Эти методы используют :ref:`.previous_siblings <sibling-generators>` для "
"перебора тех одноуровневых элементов, которые предшествуют данному "
"элементу в дереве разбора. Метод ``find_previous_siblings()`` возвращает "
"все подходящие одноуровневые элементы,, а а ``find_next_sibling()`` "
"только первый из них:: "

#: ../../bs4ru.rst:1697
msgid "``find_all_next()`` and ``find_next()``"
msgstr "``find_all_next()`` и ``find_next()`` "

#: ../../bs4ru.rst:1699
msgid ""
"Method signature: find_all_next(:ref:`name <name>`, :ref:`attrs <attrs>`,"
" :ref:`string <string>`, :ref:`limit <limit>`, :ref:`**kwargs <kwargs>`)"
msgstr ""
"Сигнатура метода: find_all_next(:ref:`name <name>`, :ref:`attrs <attrs>`,"
" :ref:`string <string>`, :ref:`limit <limit>`, :ref:`**kwargs <kwargs>`) "

#: ../../bs4ru.rst:1701
msgid ""
"Method signature: find_next(:ref:`name <name>`, :ref:`attrs <attrs>`, "
":ref:`string <string>`, :ref:`**kwargs <kwargs>`)"
msgstr ""
"Сигнатура метода: find_next(:ref:`name <name>`, :ref:`attrs <attrs>`, "
":ref:`string <string>`, :ref:`**kwargs <kwargs>`) "

#: ../../bs4ru.rst:1703
msgid ""
"These methods use :ref:`.next_elements <element-generators>` to iterate "
"over whatever tags and strings that come after it in the document. The "
"``find_all_next()`` method returns all matches, and ``find_next()`` "
"returns only the first match::"
msgstr ""
"Эти методы используют :ref:`.next_elements <element-generators>` для "
"перебора любых тегов и строк, которые встречаются в документе после "
"элемента. Метод ``find_all_next()`` возвращает все совпадения, а "
"``find_next()`` только первое:: "

#: ../../bs4ru.rst:1719
msgid ""
"In the first example, the string \"Elsie\" showed up, even though it was "
"contained within the <a> tag we started from. In the second example, the "
"last <p> tag in the document showed up, even though it's not in the same "
"part of the tree as the <a> tag we started from. For these methods, all "
"that matters is that an element matches the filter and it shows up later "
"in the document in :ref:`document order <document-order>`."
msgstr ""
"В первом примере нашлась строка \"Elsie\", хотя она содержится в теге "
"<a>, с которого мы начали. Во втором примере нашелся последний тег <p>, "
"хотя он находится в другой части дерева, чем тег <a>, с которого мы "
"начали. Для этих методов имеет значение только то, что элемент "
"соответствует фильтру и появляется в документе позже, в соответствии с "
":ref:`порядком документа <document-order>`. "

#: ../../bs4ru.rst:1727
msgid "``find_all_previous()`` and ``find_previous()``"
msgstr "``find_all_previous()`` и ``find_previous()`` "

#: ../../bs4ru.rst:1729
msgid ""
"Method signature: find_all_previous(:ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, :ref:`limit <limit>`, :ref:`**kwargs "
"<kwargs>`)"
msgstr ""
"Сигнатура метода: find_all_previous(:ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, :ref:`limit <limit>`, :ref:`**kwargs "
"<kwargs>`) "

#: ../../bs4ru.rst:1731
msgid ""
"Method signature: find_previous(:ref:`name <name>`, :ref:`attrs <attrs>`,"
" :ref:`string <string>`, :ref:`**kwargs <kwargs>`)"
msgstr ""
"Сигнатура метода: find_previous(:ref:`name <name>`, :ref:`attrs <attrs>`,"
" :ref:`string <string>`, :ref:`**kwargs <kwargs>`) "

#: ../../bs4ru.rst:1733
msgid ""
"These methods use :ref:`.previous_elements <element-generators>` to "
"iterate over the tags and strings that came before it in the document. "
"The ``find_all_previous()`` method returns all matches, and "
"``find_previous()`` only returns the first match::"
msgstr ""
"Эти методы используют :ref:`.previous_elements <element-generators>` для "
"перебора любых тегов и строк, которые встречаются в документе до "
"элемента. Метод ``find_all_previous()`` возвращает все совпадения, а "
"``find_previous()`` только первое:: "

#: ../../bs4ru.rst:1749
msgid ""
"The call to ``find_all_previous(\"p\")`` found the first paragraph in the"
" document (the one with class=\"title\"), but it also finds the second "
"paragraph, the <p> tag that contains the <a> tag we started with. This "
"shouldn't be too surprising: we're looking at all the tags that show up "
"earlier in the document in :ref:`document order <document-order>` than "
"the one we started with. A <p> tag that contains an <a> tag must have "
"shown up before the <a> tag it contains."
msgstr ""
"Вызов ``find_all_previous (\"p\")`` нашел первый абзац в документе (тот, "
"который с ``class = \"title\"``), но он также находит второй абзац, а "
"именно тег <p>, содержащий тег <a>, с которого мы начали. Это не так уж "
"удивительно: мы смотрим на все теги, которые появляются в :ref:`порядке "
"документа <document-order>` раньше , чем тот, с которого мы начали. Тег "
"<p>, содержащий тег <a>, должен был появиться до тега <a>, который в нем "
"содержится. "

#: ../../bs4ru.rst:1760
msgid "CSS selectors through the ``.css`` property"
msgstr "CSS-селекторы через свойство ``.css``"

#: ../../bs4ru.rst:1764
msgid ""
":py:class:`BeautifulSoup` and :py:class:`Tag` objects support CSS "
"selectors through their ``.css`` property. The actual selector "
"implementation is handled by the `Soup Sieve "
"<https://facelessuser.github.io/soupsieve/>`_ package, available on PyPI "
"as ``soupsieve``. If you installed Beautiful Soup through ``pip``, Soup "
"Sieve was installed at the same time, so you don't have to do anything "
"extra."
msgstr ""
"Объекты :py:class:`BeautifulSoup` и :py:class:`Tag` поддерживают "
"селекторы CSS через свойство ``.css``. Фактическая реализация селектора "
"обрабатывается пакетом `Soup Sieve "
"<https://facelessuser.github.io/soupsieve/>`_, доступным в PyPI как "
"``soupsieve``. Если вы установили Beautiful Soup через pip, одновременно "
"должен был установиться Soup Sieve, поэтому вам не нужно больше ничего "
"делать."

#: ../../bs4ru.rst:1771
msgid ""
"The Soup Sieve documentation lists `all the currently supported CSS "
"selectors <https://facelessuser.github.io/soupsieve/selectors/>`_, but "
"here are some of the basics. You can find tags by name::"
msgstr ""
"В `документации SoupSieve <https://facelessuser.github.io/soupsieve/>`_ "
"перечислены все селекторы CSS, которые поддерживаются на данный момент, "
"но вот некоторые из основных. Вы можете найти тег по имени::"

#: ../../bs4ru.rst:1781
msgid "Find tags by ID::"
msgstr "Найти теги по ID:: "

#: ../../bs4ru.rst:1789
msgid "Find tags contained anywhere within other tags::"
msgstr "Найти теги внутри других тегов на любом уровне вложенности:: "

#: ../../bs4ru.rst:1799
msgid "Find tags *directly* within other tags::"
msgstr "Найти теги *непосредственно* внутри других тегов:: "

#: ../../bs4ru.rst:1815
msgid "Find all matching next siblings of tags::"
msgstr "Найти все подходящие одноуровневые элементы тега, следующие за ним:: "

#: ../../bs4ru.rst:1821
msgid "Find the next sibling tag (but only if it matches)::"
msgstr "Найти следующий одноуровневый тег (но только если он подходит)::"

#: ../../bs4ru.rst:1826
msgid "Find tags by CSS class::"
msgstr "Найти теги по классу CSS:: "

#: ../../bs4ru.rst:1838
msgid "Find tags that match any selector from a list of selectors::"
msgstr "Найти теги, которые соответствуют любому селектору из списка:: "

#: ../../bs4ru.rst:1844
msgid "Test for the existence of an attribute::"
msgstr "Проверка на наличие атрибута:: "

#: ../../bs4ru.rst:1851
msgid "Find tags by attribute value::"
msgstr "Найти теги по значению атрибута:: "

#: ../../bs4ru.rst:1867
msgid ""
"There's also a method called ``select_one()``, which finds only the first"
" tag that matches a selector::"
msgstr ""
"Есть также метод ``select_one()``, который находит только первый тег, "
"соответствующий селектору:: "

#: ../../bs4ru.rst:1873
msgid ""
"As a convenience, you can call ``select()`` and ``select_one()`` can "
"directly on the :py:class:`BeautifulSoup` or :py:class:`Tag` object, "
"omitting the ``.css`` property::"
msgstr ""
"Для удобства вы можете вызвать метод select() и метод select_one() "
"непосредственно для объекта :py:class:`BeautifulSoup` или "
":py:class:`Tag`, опуская свойство ``.css``::"

#: ../../bs4ru.rst:1883
msgid ""
"CSS selector support is a convenience for people who already know the CSS"
" selector syntax. You can do all of this with the Beautiful Soup API. If "
"CSS selectors are all you need, you should skip Beautiful Soup altogether"
" and parse the document with ``lxml``: it's a lot faster. But Soup Sieve "
"lets you *combine* CSS selectors with the Beautiful Soup API."
msgstr ""
"Селекторы CSS удобны для тех, кто уже знаком с синтаксисом селекторов "
"CSS. Вы можете сделать все это с помощью Beautiful Soup API. И если CSS "
"селекторы — это все, что вам нужно, вам следует использовать парсер lxml:"
" так будет намного быстрее. Но вы можете *комбинировать* селекторы CSS с "
"Beautiful Soup API. "

#: ../../bs4ru.rst:1891
msgid "Advanced Soup Sieve features"
msgstr "Расширенные возможности Soup Sieve"

#: ../../bs4ru.rst:1893
msgid ""
"Soup Sieve offers a substantial API beyond the ``select()`` and "
"``select_one()`` methods, and you can access most of that API through the"
" ``.css`` attribute of :py:class:`Tag` or :py:class:`BeautifulSoup`. What"
" follows is just a list of the supported methods; see `the Soup Sieve "
"documentation <https://facelessuser.github.io/soupsieve/>`_ for full "
"documentation."
msgstr ""
"Soup Sieve предлагает обширный API, помимо методов ``select()`` и "
"``select_one()``, и вы можете получить доступ к большей части этого API "
"через атрибут .css :py:class:`Tag` или :py:class:`BeautifulSoup`. Далее "
"следует лишь список поддерживаемых методов; полное руководство см. в "
"`документации Soup Sieve <https://facelessuser.github.io/soupsieve/>`_."

#: ../../bs4ru.rst:1900
msgid ""
"The ``iselect()`` method works the same as ``select()``, but it returns a"
" generator instead of a list::"
msgstr ""
"Метод ``iselect()`` работает так же, как ``select()``, но вместо списка "
"возвращает генератор::"

#: ../../bs4ru.rst:1906
msgid ""
"The ``closest()`` method returns the nearest parent of a given "
":py:class:`Tag` that matches a CSS selector, similar to Beautiful Soup's "
"``find_parent()`` method::"
msgstr ""
"Метод ``closest()`` возвращает ближайшего родителя данного "
":py:class:`Tag`, который соответствует селектору CSS, аналогично методу "
"``find_parent()`` в Beautiful Soup::"

#: ../../bs4ru.rst:1918
msgid ""
"The ``match()`` method returns a Boolean depending on whether or not a "
"specific :py:class:`Tag` matches a selector::"
msgstr ""
"Метод ``match()`` возвращает логическое значение в зависимости от того, "
"соответствует ли конкретный :py:class:`Tag` селектору::"

#: ../../bs4ru.rst:1927
msgid ""
"The ``filter()`` method returns the subset of a tag's direct children "
"that match a selector::"
msgstr ""
"Метод ``filter()`` возвращает подмножество прямых дочерних элементов "
"тега, соответствующих селектору::"

#: ../../bs4ru.rst:1933
msgid ""
"The ``escape()`` method escapes CSS identifiers that would otherwise be "
"invalid::"
msgstr ""
"Метод ``escape()`` экранирует идентификаторы CSS, которые в противном "
"случае были бы недействительны::"

#: ../../bs4ru.rst:1940
msgid "Namespaces in CSS selectors"
msgstr "Пространства имен в селекторах CSS "

#: ../../bs4ru.rst:1942
msgid ""
"If you've parsed XML that defines namespaces, you can use them in CSS "
"selectors.::"
msgstr ""
"Если вы разобрали XML, в котором определены пространства имен, вы можете "
"использовать их в селекторах CSS::"

#: ../../bs4ru.rst:1958
msgid ""
"Beautiful Soup tries to use namespace prefixes that make sense based on "
"what it saw while parsing the document, but you can always provide your "
"own dictionary of abbreviations::"
msgstr ""
"Beautiful Soup пытается использовать префиксы пространства имен, которые "
"имеют смысл в зависимости от того, что он увидел при разборе документа, "
"но вы всегда можете предоставить свой словарь сокращений::   "

#: ../../bs4ru.rst:1967
msgid "History of CSS selector support"
msgstr "История поддержки селекторов CSS"

#: ../../bs4ru.rst:1969
msgid ""
"The ``.css`` property was added in Beautiful Soup 4.12.0. Prior to this, "
"only the ``.select()`` and ``.select_one()`` convenience methods were "
"supported."
msgstr ""
"Свойство ``.css`` было добавлено в Beautiful Soup 4.12.0. До этого "
"поддерживались только методы ``.select()`` и ``.select_one()``."

#: ../../bs4ru.rst:1973
msgid ""
"The Soup Sieve integration was added in Beautiful Soup 4.7.0. Earlier "
"versions had the ``.select()`` method, but only the most commonly-used "
"CSS selectors were supported."
msgstr ""
"Интеграция Soup Sieve была добавлена в Beautiful Soup 4.7.0. В более "
"ранних версиях также есть метод ``.select()``, но поддерживаются только "
"самые часто используемые селекторы CSS."

#: ../../bs4ru.rst:1978
msgid "Modifying the tree"
msgstr "Изменение дерева "

#: ../../bs4ru.rst:1980
msgid ""
"Beautiful Soup's main strength is in searching the parse tree, but you "
"can also modify the tree and write your changes as a new HTML or XML "
"document."
msgstr ""
"Основная сила Beautiful Soup в поиске по дереву разбора, но вы также "
"можете изменить дерево и записать свои изменения в виде нового HTML или "
"XML-документа. "

#: ../../bs4ru.rst:1985
msgid "Changing tag names and attributes"
msgstr "Изменение имен тегов и атрибутов "

#: ../../bs4ru.rst:1987
msgid ""
"I covered this earlier, in :py:attr:`Tag.attrs`, but it bears repeating. "
"You can rename a tag, change the values of its attributes, add new "
"attributes, and delete attributes::"
msgstr ""
"Я говорил об этом раньше, в разделе :py:attr:`Tag.attrs`, но это стоит "
"повторить. Вы можете переименовать тег, изменить значения его атрибутов, "
"добавить новые атрибуты и удалить атрибуты::"

#: ../../bs4ru.rst:2006
msgid "Modifying ``.string``"
msgstr "Изменение ``.string`` "

#: ../../bs4ru.rst:2008
msgid ""
"If you set a tag's ``.string`` attribute to a new string, the tag's "
"contents are replaced with that string::"
msgstr ""
"Если вы замените значение атрибута ``.string`` новой строкой, содержимое "
"тега будет заменено на эту строку::"

#: ../../bs4ru.rst:2019
msgid ""
"Be careful: if the tag contained other tags, they and all their contents "
"will be destroyed."
msgstr ""
"Будьте осторожны: если тег содержит другие теги, они и все их содержимое "
"будут уничтожены."

#: ../../bs4ru.rst:2023
msgid "``append()``"
msgstr "``append()``"

#: ../../bs4ru.rst:2025
msgid ""
"You can add to a tag's contents with ``Tag.append()``. It works just like"
" calling ``.append()`` on a Python list::"
msgstr ""
"Вы можете добавить содержимое тега с помощью ``Tag.append()``. Это "
"работает точно так же, как ``.append()`` для списка в Python:: "

#: ../../bs4ru.rst:2038
msgid "``Tag.append()`` returns the newly appended element."
msgstr ""
"``Tag.append()`` возвращает недавно добавленный элемент."

#: ../../bs4ru.rst:2041
msgid "``extend()``"
msgstr "``extend()`` "

#: ../../bs4ru.rst:2043
msgid ""
"Starting in Beautiful Soup 4.7.0, :py:class:`Tag` also supports a method "
"called ``.extend()``, which adds every element of a list to a "
":py:class:`Tag`, in order::"
msgstr ""
"Начиная с версии Beautiful Soup 4.7.0, :py:class:`Tag` также поддерживает"
" метод ``.extend()``, который добавляет каждый элемент списка в "
":py:class:`Tag` по порядку:: "

#: ../../bs4ru.rst:2055
msgid "``Tag.extend()`` returns the list of appended elements."
msgstr ""
"``Tag.extend()`` возвращает список присоединенных элементов."

#: ../../bs4ru.rst:2058
msgid "``NavigableString()`` and ``.new_tag()``"
msgstr "``NavigableString()`` и ``.new_tag()`` "

#: ../../bs4ru.rst:2060
msgid ""
"If you need to add a string to a document, no problem—you can pass a "
"Python string in to ``append()``, or you can call the "
":py:class:`NavigableString` constructor::"
msgstr ""
"Если вам нужно добавить строку в документ, нет проблем — вы можете "
"передать строку Python в ``append()`` или вызвать конструктор "
":py:class:`NavigableString`:: "

#: ../../bs4ru.rst:2075
msgid ""
"If you want to create a comment or some other subclass of "
":py:class:`NavigableString`, just call the constructor::"
msgstr ""
"Если вы хотите создать комментарий или другой подкласс "
":py:class:`NavigableString`, просто вызовите конструктор:: "

#: ../../bs4ru.rst:2086
msgid "*(This is a new feature in Beautiful Soup 4.4.0.)*"
msgstr "(Это новая функция в Beautiful Soup 4.4.0.) "

#: ../../bs4ru.rst:2088
msgid ""
"What if you need to create a whole new tag? The best solution is to call "
"the factory method ``BeautifulSoup.new_tag()``::"
msgstr ""
"Что делать, если вам нужно создать совершенно новый тег? Наилучшим "
"решением будет вызвать фабричный метод ``BeautifulSoup.new_tag()``:: "

#: ../../bs4ru.rst:2099
msgid "Only the first argument, the tag name, is required."
msgstr "Нужен только первый аргумент, имя тега. "

#: ../../bs4ru.rst:2101
msgid ""
"*(The ``string`` argument to ``new_tag`` was introduced in Beautiful Soup"
" 4.13.0.)*"
msgstr ""
"*(Аргумент ``string`` для ``new_tag`` был введен в Beautiful Soup 4.13.0.)*"

#: ../../bs4ru.rst:2103
msgid ""
"Because insertion methods return the newly inserted element, you can "
"create, insert, and obtain an element in one step::"
msgstr ""
"Поскольку методы вставки возвращают недавно вставленный элемент, вы можете создать, вставить и получить элемент за один шаг::"

#: ../../bs4ru.rst:2112
msgid "``insert()``"
msgstr "``insert()`` "

#: ../../bs4ru.rst:2114
msgid ""
"``Tag.insert()`` is just like ``Tag.append()``, except the new element "
"doesn't necessarily go at the end of its parent's ``.contents``. It will "
"be inserted at whatever numeric position you say, similar to "
"``.insert()`` on a Python list::"
msgstr ""
"``Tag.insert()`` похож на ``Tag.append()``, за исключением того, что "
"новый элемент не обязательно добавляется в конец родительского "
"``.contents``. Он добавится в любое место, номер которого вы укажете. Это"
" работает в точности как ``.insert()`` в списке Python:: "

#: ../../bs4ru.rst:2131
msgid ""
"You can pass more than one element into ``Tag.insert()``. All the "
"elements will be inserted, starting at the numeric position you provide."
msgstr ""
"Вы можете передать более одного элемента в ``Tag.insert()``. Все элементы будут вставлены, начиная с указанной вами числовой позиции."

#: ../../bs4ru.rst:2135
msgid "``Tag.insert()`` returns the list of newly inserted elements."
msgstr ""
"``Tag.insert()`` возвращает список недавно вставленных элементов."

#: ../../bs4ru.rst:2138
msgid "``insert_before()`` and ``insert_after()``"
msgstr "``insert_before()`` и ``insert_after()`` "

#: ../../bs4ru.rst:2140
msgid ""
"The ``insert_before()`` method inserts tags or strings immediately before"
" something else in the parse tree::"
msgstr ""
"Метод ``insert_before()`` вставляет теги или строки непосредственно перед"
" чем-то в дереве разбора:: "

#: ../../bs4ru.rst:2150
msgid ""
"The ``insert_after()`` method inserts tags or strings immediately after "
"something else in the parse tree::"
msgstr ""
"Метод ``insert_after()`` вставляет теги или строки непосредственно после "
"чего-то в дереве разбора:: "

#: ../../bs4ru.rst:2161
msgid "Both methods return the list of newly inserted elements."
msgstr ""
"Оба метода возвращают список недавно вставленных элементов."

#: ../../bs4ru.rst:2164
msgid "``clear()``"
msgstr "``clear()`` "

#: ../../bs4ru.rst:2166
msgid "``Tag.clear()`` removes the contents of a tag::"
msgstr "``Tag.clear()`` удаляет содержимое тега::"

#: ../../bs4ru.rst:2177
msgid "``extract()``"
msgstr "``extract()`` "

#: ../../bs4ru.rst:2179
msgid ""
"``PageElement.extract()`` removes a tag or string from the tree. It "
"returns the tag or string that was extracted::"
msgstr ""
"``PageElement.extract()`` удаляет тег или строку из дерева. Он возвращает"
" тег или строку, которая была извлечена:: "

#: ../../bs4ru.rst:2197
msgid ""
"At this point you effectively have two parse trees: one rooted at the "
":py:class:`BeautifulSoup` object you used to parse the document, and one "
"rooted at the tag that was extracted. You can go on to call ``extract()``"
" on a child of the element you extracted::"
msgstr ""
"К этому моменту у вас фактически есть два дерева разбора: одно в объекте "
":py:class:`BeautifulSoup`, который вы использовали, чтобы разобрать "
"документ, другое в теге, который был извлечен. Вы можете далее вызывать "
"``extract`` в отношении дочернего элемента того тега, который был "
"извлечен:: "

#: ../../bs4ru.rst:2213
msgid "``decompose()``"
msgstr "``decompose()`` "

#: ../../bs4ru.rst:2215
msgid ""
"``Tag.decompose()`` removes a tag from the tree, then *completely "
"destroys it and its contents*::"
msgstr ""
"``Tag.decompose()`` удаляет тег из дерева, а затем *полностью уничтожает "
"его вместе с его содержимым*:: "

#: ../../bs4ru.rst:2227
msgid ""
"The behavior of a decomposed :py:class:`Tag` or "
":py:class:`NavigableString` is not defined and you should not use it for "
"anything. If you're not sure whether something has been decomposed, you "
"can check its ``.decomposed`` property *(new in Beautiful Soup 4.9.0)*::"
msgstr ""
"Поведение уничтоженного :py:class:`Tag` или :py:class:`NavigableString` "
"не определено, и вам не следует его использовать. Если вы не уверены, "
"было ли что-то уничтожено, вы можете проверить по его свойству "
"``decomposed`` *(новое в Beautiful Soup 4.9.0)*:: "

#: ../../bs4ru.rst:2241
msgid "``replace_with()``"
msgstr "``replace_with()`` "

#: ../../bs4ru.rst:2243
msgid ""
"``PageElement.replace_with()`` extracts a tag or string from the tree, "
"then replaces it with one or more tags or strings of your choice::"
msgstr ""
"``PageElement.extract()`` извлекает тег или строку из дерева и заменяет "
"его одним или несколькими тегами либо строками по вашему выбору:: "

#: ../../bs4ru.rst:2266
msgid ""
"``replace_with()`` returns the tag or string that got replaced, so that "
"you can examine it or add it back to another part of the tree."
msgstr ""
"``replace_with()`` возвращает тег или строку, которые были заменены, так "
"что вы можете изучить его или добавить его обратно в другую часть дерева."

#: ../../bs4ru.rst:2269
msgid ""
"*The ability to pass multiple arguments into replace_with() is new in "
"Beautiful Soup 4.10.0.*"
msgstr ""
"*Возможность передавать несколько аргументов в replace_with() является "
"новой в Beautiful Soup 4.10.0.* "

#: ../../bs4ru.rst:2273
msgid "``wrap()``"
msgstr "``wrap()`` "

#: ../../bs4ru.rst:2275
msgid ""
"``PageElement.wrap()`` wraps an element in the :py:class:`Tag` object you"
" specify. It returns the new wrapper::"
msgstr ""
"``PageElement.wrap()`` обертывает элемент в указанный вами объект "
":py:class:`Tag`. Он возвращает новую обертку:: "

#: ../../bs4ru.rst:2285
msgid "*This method is new in Beautiful Soup 4.0.5.*"
msgstr "*Это новый метод в Beautiful Soup 4.0.5.*"

#: ../../bs4ru.rst:2288
msgid "``unwrap()``"
msgstr "``unwrap()`` "

#: ../../bs4ru.rst:2290
msgid ""
"``Tag.unwrap()`` is the opposite of ``wrap()``. It replaces a tag with "
"whatever's inside that tag. It's good for stripping out markup::"
msgstr ""
"``Tag.unwrap()`` — это противоположность ``wrap()``. Он заменяет весь тег"
" на его содержимое. Этим методом удобно очищать разметку:: "

#: ../../bs4ru.rst:2301
msgid "Like ``replace_with()``, ``unwrap()`` returns the tag that was replaced."
msgstr ""
"Как и ``replace_with()``, ``unwrap()`` возвращает тег, который был "
"заменен. "

#: ../../bs4ru.rst:2305
msgid "``smooth()``"
msgstr "``smooth()`` "

#: ../../bs4ru.rst:2307
msgid ""
"After calling a bunch of methods that modify the parse tree, you may end "
"up with two or more :py:class:`NavigableString` objects next to each "
"other. Beautiful Soup doesn't have any problems with this, but since it "
"can't happen in a freshly parsed document, you might not expect behavior "
"like the following::"
msgstr ""
"После вызова ряда методов, которые изменяют дерево разбора, у вас может "
"оказаться несколько объектов :py:class:`NavigableString` подряд. У "
"Beautiful Soup с этим нет проблем, но поскольку такое не случается со "
"свежеразобранным документом, вам может показаться неожиданным следующее "
"поведение:: "

#: ../../bs4ru.rst:2328
msgid ""
"You can call ``Tag.smooth()`` to clean up the parse tree by consolidating"
" adjacent strings::"
msgstr ""
"Вы можете вызвать ``Tag.smooth()``, чтобы очистить дерево разбора путем "
"объединения смежных строк:: "

#: ../../bs4ru.rst:2340
msgid "*This method is new in Beautiful Soup 4.8.0.*"
msgstr "*Это новый метод в Beautiful Soup 4.8.0.*"

#: ../../bs4ru.rst:2343
msgid "Output"
msgstr "Вывод "

#: ../../bs4ru.rst:2348
msgid "Pretty-printing"
msgstr "Красивое форматирование "

#: ../../bs4ru.rst:2350
msgid ""
"The ``prettify()`` method will turn a Beautiful Soup parse tree into a "
"nicely formatted Unicode string, with a separate line for each tag and "
"each string::"
msgstr ""
"Метод ``prettify()`` превратит дерево разбора Beautiful Soup в красиво "
"отформатированную строку Unicode, где каждый тег и каждая строка "
"выводятся на отдельной строчке:: "

#: ../../bs4ru.rst:2373
msgid ""
"You can call ``prettify()`` on the top-level :py:class:`BeautifulSoup` "
"object, or on any of its :py:class:`Tag` objects::"
msgstr ""
"Вы можете вызвать ``prettify()`` для объекта :py:class:`BeautifulSoup` "
"верхнего уровня или для любого из его объектов :py:class:`Tag`:: "

#: ../../bs4ru.rst:2384
msgid ""
"Since it adds whitespace (in the form of newlines), ``prettify()`` "
"changes the meaning of an HTML document and should not be used to "
"reformat one. The goal of ``prettify()`` is to help you visually "
"understand the structure of the documents you work with."
msgstr ""
"Добавляя переводы строк (``\\n``), метод ``prettify()`` изменяет значение"
" документа HTML и не должен использоваться для переформатирования. Цель "
"``prettify()`` — помочь вам визуально понять структуру документов, с "
"которыми вы работаете. "

#: ../../bs4ru.rst:2390
msgid "Non-pretty printing"
msgstr "Без красивого форматирования "

#: ../../bs4ru.rst:2392
msgid ""
"If you just want a string, with no fancy formatting, you can call "
"``str()`` on a :py:class:`BeautifulSoup` object, or on a :py:class:`Tag` "
"within it::"
msgstr ""
"Если вам нужна просто строка, без особого форматирования, вы можете "
"вызвать ``str()`` для объекта :py:class:`BeautifulSoup` или для объекта "
":py:class:`Tag` внутри него:: "

#: ../../bs4ru.rst:2401
msgid ""
"The ``str()`` function returns a string encoded in UTF-8. See "
"`Encodings`_ for other options."
msgstr ""
"Функция ``str()`` возвращает строку, кодированную в UTF-8. Для получения "
"более подробной информации см. `Кодировки`_. "

#: ../../bs4ru.rst:2404
msgid ""
"You can also call ``encode()`` to get a bytestring, and ``decode()`` to "
"get Unicode."
msgstr ""
"Вы также можете вызвать ``encode()`` для получения байтовой строки, и "
"``decode()``, чтобы получить Unicode. "

#: ../../bs4ru.rst:2410
msgid "Output formatters"
msgstr "Средства форматирования вывода "

#: ../../bs4ru.rst:2412
msgid ""
"If you give Beautiful Soup a document that contains HTML entities like "
"\"&lquot;\", they'll be converted to Unicode characters::"
msgstr ""
"Если вы дадите Beautiful Soup документ, который содержит HTML-мнемоники, "
"такие как \"&lquot;\", они будут преобразованы в символы Unicode:: "

#: ../../bs4ru.rst:2419
msgid ""
"If you then convert the document to a bytestring, the Unicode characters "
"will be encoded as UTF-8. You won't get the HTML entities back::"
msgstr ""
"Если затем преобразовать документ в байтовую строку, символы Unicode "
"будут кодироваться как UTF-8. Вы не получите обратно HTML-мнемоники:: "

#: ../../bs4ru.rst:2425
msgid ""
"By default, the only characters that are escaped upon output are bare "
"ampersands and angle brackets. These get turned into \"&amp;\", \"&lt;\","
" and \"&gt;\", so that Beautiful Soup doesn't inadvertently generate "
"invalid HTML or XML::"
msgstr ""
"По умолчанию единственные символы, которые экранируются при выводе — это "
"чистые амперсанды и угловые скобки. Они превращаются в «&», «<» и \">\", "
"чтобы Beautiful Soup случайно не сгенерировал невалидный HTML или XML:: "

#: ../../bs4ru.rst:2438
msgid ""
"You can change this behavior by providing a value for the ``formatter`` "
"argument to ``prettify()``, ``encode()``, or ``decode()``. Beautiful Soup"
" recognizes five possible values for ``formatter``."
msgstr ""
"Вы можете изменить это поведение, указав для аргумента ``formatter`` одно"
" из значений: ``prettify()``, ``encode()`` или ``decode()``. Beautiful "
"Soup распознает пять возможных значений ``formatter``. "

#: ../../bs4ru.rst:2443
msgid ""
"The default is ``formatter=\"minimal\"``. Strings will only be processed "
"enough to ensure that Beautiful Soup generates valid HTML/XML::"
msgstr ""
"Значение по умолчанию — ``formatter=\"minimal\"``. Строки будут "
"обрабатываться ровно настолько, чтобы Beautiful Soup генерировал валидный"
" HTML / XML:: "

#: ../../bs4ru.rst:2453
msgid ""
"If you pass in ``formatter=\"html\"``, Beautiful Soup will convert "
"Unicode characters to HTML entities whenever possible::"
msgstr ""
"Если вы передадите ``formatter = \"html\"``, Beautiful Soup преобразует "
"символы Unicode в HTML-мнемоники, когда это возможно:: "

#: ../../bs4ru.rst:2461
msgid ""
"If you pass in ``formatter=\"html5\"``, it's similar to "
"``formatter=\"html\"``, but Beautiful Soup will omit the closing slash in"
" HTML void tags like \"br\"::"
msgstr ""
"Если вы передаете ``formatter=\"html5\"``, это то же самое, что "
"``formatter=\"html\"``, только Beautiful Soup будет пропускать "
"закрывающую косую черту в пустых тегах HTML, таких как \"br\"::"

#: ../../bs4ru.rst:2473
msgid ""
"In addition, any attributes whose values are the empty string will become"
" HTML-style Boolean attributes::"
msgstr ""
"Кроме того, любые атрибуты, значения которых являются пустой строкой "
"станут логическими атрибутами в стиле HTML::   "

#: ../../bs4ru.rst:2483
msgid "*(This behavior is new as of Beautiful Soup 4.10.0.)*"
msgstr "*(Это новое поведение в Beautiful Soup 4.10.0.)*   "

#: ../../bs4ru.rst:2485
msgid ""
"If you pass in ``formatter=None``, Beautiful Soup will not modify strings"
" at all on output. This is the fastest option, but it may lead to "
"Beautiful Soup generating invalid HTML/XML, as in these examples::"
msgstr ""
"Если вы передадите ``formatter=None``, Beautiful Soup вообще не будет "
"менять строки на выходе. Это самый быстрый вариант, но он может привести "
"к тому, что Beautiful Soup будет генерировать невалидный HTML / XML:: "

#: ../../bs4ru.rst:2499
msgid "Formatter objects"
msgstr "Объекты форматирования"

#: ../../bs4ru.rst:2501
msgid ""
"If you need more sophisticated control over your output, you can "
"instantiate one of Beautiful Soup's formatter classes and pass that "
"object in as ``formatter``."
msgstr ""
"Если вам нужен более сложный контроль над выводом, вы можете создать "
"экземпляр одного из классов форматирования Beautiful Soup и передать этот"
" объект как ``formatter``."

#: ../../bs4ru.rst:2507
msgid "Used to customize the formatting rules for HTML documents."
msgstr "Используется для настройки правил форматирования HTML-документов."

#: ../../bs4ru.rst:2509
msgid ""
"Here's a formatter that converts strings to uppercase, whether they occur"
" in a string object or an attribute value::"
msgstr ""
"Вот как можно преобразовать строки в верхний регистр, независимо от того,"
" находятся ли они в строковом объекте или в значении атрибута::"

#: ../../bs4ru.rst:2528
msgid ""
"Here's a formatter that increases the indentation width when pretty-"
"printing::"
msgstr "Так можно увеличить отступ при красивом форматировании::   "

#: ../../bs4ru.rst:2538
msgid "Used to customize the formatting rules for XML documents."
msgstr "Используется для настройки правил форматирования XML-документов."

#: ../../bs4ru.rst:2541
msgid "Writing your own formatter"
msgstr "Написание собственного форматтера"

#: ../../bs4ru.rst:2543
msgid ""
"Subclassing :py:class:`HTMLFormatter` or :py:class:`XMLFormatter` will "
"give you even more control over the output. For example, Beautiful Soup "
"sorts the attributes in every tag by default::"
msgstr ""
"Подклассы :py:class:`HTMLFormatter` или :py:class:`XMLFormatter` дают еще"
" больший контроль над выводом. Например, Beautiful Soup сортирует "
"атрибуты в каждом теге по умолчанию:: "

#: ../../bs4ru.rst:2551
msgid ""
"To turn this off, you can subclass the ``Formatter.attributes()`` method,"
" which controls which attributes are output and in what order. This "
"implementation also filters out the attribute called \"m\" whenever it "
"appears::"
msgstr ""
"Чтобы выключить сортировку по умолчанию, вы можете создать подкласс  на "
"основе метода ``Formatter.attributes()``, который контролирует, какие "
"атрибуты выводятся и в каком порядке. Эта реализация также "
"отфильтровывает атрибут с именем \"m\", где бы он ни появился::"

#: ../../bs4ru.rst:2566
msgid ""
"One last caveat: if you create a :py:class:`CData` object, the text "
"inside that object is always presented *exactly as it appears, with no "
"formatting*. Beautiful Soup will call your entity substitution function, "
"just in case you've written a custom function that counts all the strings"
" in the document or something, but it will ignore the return value::"
msgstr ""
"Последнее предостережение: если вы создаете объект :py:class:`CData`, "
"текст внутри этого объекта всегда представлен *как есть, без какого-либо "
"форматирования*. Beautiful Soup вызовет вашу функцию для замены мнемоник,"
" на тот случай, если вы написали функцию, которая подсчитывает все строки"
" в документе или что-то еще, но он будет игнорировать возвращаемое "
"значение:: "

#: ../../bs4ru.rst:2583
msgid "``get_text()``"
msgstr "``get_text()`` "

#: ../../bs4ru.rst:2585
msgid ""
"If you only want the human-readable text inside a document or tag, you "
"can use the ``get_text()`` method. It returns all the text in a document "
"or beneath a tag, as a single Unicode string::"
msgstr ""
"Если вам нужен только человекочитаемый текст внутри документа или тега, "
"используйте метод ``get_text()``. Он возвращает весь текст документа или "
"тега в виде единственной строки Unicode:: "

#: ../../bs4ru.rst:2597
msgid "You can specify a string to be used to join the bits of text together::"
msgstr ""
"Вы можете указать строку, которая будет использоваться для объединения "
"текстовых фрагментов в единую строку:: "

#: ../../bs4ru.rst:2603
msgid ""
"You can tell Beautiful Soup to strip whitespace from the beginning and "
"end of each bit of text::"
msgstr ""
"Вы можете сказать Beautiful Soup удалять пробелы в начале и конце каждого"
" текстового фрагмента:: "

#: ../../bs4ru.rst:2609
msgid ""
"But at that point you might want to use the :ref:`.stripped_strings "
"<string-generators>` generator instead, and process the text yourself::"
msgstr ""
"Но в этом случае вы можете предпочесть использовать генератор "
":ref:`.stripped_strings <string-generators>` и затем обработать текст "
"самостоятельно:: "

#: ../../bs4ru.rst:2615
msgid ""
"*As of Beautiful Soup version 4.9.0, when lxml or html.parser are in use,"
" the contents of <script>, <style>, and <template> tags are generally not"
" considered to be 'text', since those tags are not part of the human-"
"visible content of the page.*"
msgstr ""
"*Начиная с версии Beautiful Soup 4.9.0, в которой используются парсеры "
"lxml или html.parser, содержание тегов <script>, <style> и <template> "
"обычно не считается 'текстом', так как эти теги не являются частью "
"воспринимаемого человеком содержания страницы.* "

#: ../../bs4ru.rst:2620
msgid ""
"*As of Beautiful Soup version 4.10.0, you can call get_text(), .strings, "
"or .stripped_strings on a NavigableString object. It will either return "
"the object itself, or nothing, so the only reason to do this is when "
"you're iterating over a mixed list.*"
msgstr ""
"*Начиная с Beautiful Soup версии 4.10.0, вы можете вызывать get_text(), "
".strings или .stripped_strings в объекте NavigableString. Это вернет либо"
" сам объект, либо ничего, поэтому единственный случай, когда стоит это "
"делать — это когда вы перебираете смешанный список (mixed list).*"

#: ../../bs4ru.rst:2625
msgid ""
"*As of Beautiful Soup version 4.13.0, you can call .string on a "
"NavigableString object. It will return the object itself, so again, the "
"only reason to do this is when you're iterating over a mixed list.*"
msgstr ""
"*Начиная с версии Beautiful Soup 4.13.0, вы можете вызывать .string "
"для объекта NavigableString. Он вернет сам объект, так что, повторюсь, "
"единственная причина делать это — когда вы перебираете смешанный список*"

#: ../../bs4ru.rst:2631
msgid "Specifying the parser to use"
msgstr "Указание парсера "

#: ../../bs4ru.rst:2633
msgid ""
"If you just need to parse some HTML, you can dump the markup into the "
":py:class:`BeautifulSoup` constructor, and it'll probably be fine. "
"Beautiful Soup will pick a parser for you and parse the data. But there "
"are a few additional arguments you can pass in to the constructor to "
"change which parser is used."
msgstr ""
"Если вам нужно просто разобрать HTML, вы можете скинуть разметку в "
"конструктор :py:class:`BeautifulSoup`, и, скорее всего, все будет в "
"порядке. Beautiful Soup подберет для вас парсер и проанализирует данные. "
"Но есть несколько дополнительных аргументов, которые вы можете передать "
"конструктору, чтобы изменить используемый парсер. "

#: ../../bs4ru.rst:2639
msgid ""
"The first argument to the :py:class:`BeautifulSoup` constructor is a "
"string or an open filehandle—the source of the markup you want parsed. "
"The second argument is *how* you'd like the markup parsed."
msgstr ""
"Первым аргументом конструктора :py:class:`BeautifulSoup` является строка "
"или открытый дескриптор файла — сама разметка, которую вы хотите "
"разобрать. Второй аргумент — это *как* вы хотите, чтобы разметка была "
"разобрана. "

#: ../../bs4ru.rst:2643
msgid ""
"If you don't specify anything, you'll get the best HTML parser that's "
"installed. Beautiful Soup ranks lxml's parser as being the best, then "
"html5lib's, then Python's built-in parser. You can override this by "
"specifying one of the following:"
msgstr ""
"Если вы ничего не укажете, будет использован лучший HTML-парсер из тех, "
"которые установлены. Beautiful Soup оценивает парсер lxml как лучший, за "
"ним идет html5lib, затем встроенный парсер Python. Вы можете "
"переопределить используемый парсер, указав что-то из следующего: "

#: ../../bs4ru.rst:2648
msgid ""
"What type of markup you want to parse. Currently supported values are "
"\"html\", \"xml\", and \"html5\"."
msgstr ""
"Какой тип разметки вы хотите разобрать. В данный момент поддерживаются "
"значения \"html\", \"xml\" и \"html5\". "

#: ../../bs4ru.rst:2651
msgid ""
"The name of the parser library you want to use. Currently supported "
"options are \"lxml\", \"html5lib\", and \"html.parser\" (Python's built-"
"in HTML parser)."
msgstr ""
"Имя библиотеки парсера, которую вы хотите использовать. В данный момент "
"поддерживаются \"lxml\", \"html5lib\" и \"html.parser\" (встроенный в "
"Python парсер HTML). "

#: ../../bs4ru.rst:2655
msgid "The section `Installing a parser`_ contrasts the supported parsers."
msgstr ""
"В разделе `Установка парсера`_ вы найдете сравнительную таблицу "
"поддерживаемых парсеров. "

#: ../../bs4ru.rst:2657
msgid ""
"If you ask for a parser that isn't installed, Beautiful Soup will raise "
"an exception so that you don't inadvertently parse a document under an "
"unknown set of rules. For example, right now, the only supported XML "
"parser is lxml. If you don't have lxml installed, asking for an XML "
"parser won't give you one, and asking for \"lxml\" won't work either."
msgstr ""
"Если вы запросите парсер, который не установлен, Beautiful Soup "
"сгенерирует исключение, чтобы вы случайно не проанализировали документ "
"в соответствии с неизвестным набором правил. Например, на текущий момент "
"единственный поддерживаемый парсер XML — это lxml. Если у вас не "
"установлен lxml, запрос на парсер XML ничего не даст, и запрос \"lxml\" "
"тоже не сработает. "

#: ../../bs4ru.rst:2665
msgid "Differences between parsers"
msgstr "Различия между парсерами "

#: ../../bs4ru.rst:2667
msgid ""
"Beautiful Soup presents the same interface to a number of different "
"parsers, but each parser is different. Different parsers will create "
"different parse trees from the same document. The biggest differences are"
" between the HTML parsers and the XML parsers. Here's a short document, "
"parsed as HTML using the parser that comes with Python::"
msgstr ""
"Beautiful Soup представляет один интерфейс для разных парсеров, но "
"парсеры неодинаковы. Разные парсеры создадут различные деревья разбора из"
" одного и того же документа. Самые большие различия будут между парсерами"
" HTML и парсерами XML. Вот короткий документ, разобранный как HTML "
"встроенным в Python парсером:: "

#: ../../bs4ru.rst:2676
msgid ""
"Since a standalone <b/> tag is not valid HTML, html.parser turns it into "
"a <b></b> tag pair."
msgstr ""
"Поскольку одиночный тег <b/> не является валидным кодом HTML, парсер "
"преобразует его в пару тегов <b></b>. "

#: ../../bs4ru.rst:2679
msgid ""
"Here's the same document parsed as XML (running this requires that you "
"have lxml installed). Note that the standalone <b/> tag is left alone, "
"and that the document is given an XML declaration instead of being put "
"into an <html> tag.::"
msgstr ""
"Вот тот же документ, который разобран как XML (для его запуска нужно, "
"чтобы был установлен lxml). Обратите внимание, что одиночный тег <b/> "
"остается, и что в документ добавляется объявление XML вместо тега "
"<html>:: "

#: ../../bs4ru.rst:2688
msgid ""
"There are also differences between HTML parsers. If you give Beautiful "
"Soup a perfectly-formed HTML document, these differences won't matter. "
"One parser will be faster than another, but they'll all give you a data "
"structure that looks exactly like the original HTML document."
msgstr ""
"Есть также различия между парсерами HTML. Если вы даете Beautiful Soup "
"идеально оформленный документ HTML, эти различия не будут иметь значения."
" Один парсер будет быстрее другого, но все они будут давать структуру "
"данных, которая выглядит точно так же, как оригинальный документ HTML. "

#: ../../bs4ru.rst:2694
msgid ""
"But if the document is not perfectly-formed, different parsers will give "
"different results. Here's a short, invalid document parsed using lxml's "
"HTML parser. Note that the <a> tag gets wrapped in <body> and <html> "
"tags, and the dangling </p> tag is simply ignored::"
msgstr ""
"Но если документ оформлен неидеально, различные парсеры дадут разные "
"результаты. Вот короткий невалидный документ, разобранный с помощью "
"HTML-парсера lxml. Обратите внимание, что тег <a> заключен в теги <body> "
"и <html>, а висячий тег </p> просто игнорируется:: "

#: ../../bs4ru.rst:2702
msgid "Here's the same document parsed using html5lib::"
msgstr "Вот тот же документ, разобранный с помощью html5lib:: "

#: ../../bs4ru.rst:2707
msgid ""
"Instead of ignoring the dangling </p> tag, html5lib pairs it with an "
"opening <p> tag. html5lib also adds an empty <head> tag; lxml didn't "
"bother."
msgstr ""
"Вместо того, чтобы игнорировать висячий тег </p>, html5lib добавляет "
"открывающй тег <p>. html5lib также добавляет пустой тег <head>; lxml "
"этого не сделал. "

#: ../../bs4ru.rst:2711
msgid "Here's the same document parsed with Python's built-in HTML parser::"
msgstr ""
"Вот тот же документ, разобранный с помощью встроенного в Python парсера "
"HTML:: "

#: ../../bs4ru.rst:2717
msgid ""
"Like lxml, this parser ignores the closing </p> tag. Unlike html5lib or "
"lxml, this parser makes no attempt to create a well-formed HTML document "
"by adding <html> or <body> tags."
msgstr ""
"Как и lxml, этот парсер игнорирует закрывающий тег </p>. В отличие от "
"html5lib, этот парсер не делает попытки создать правильно оформленный "
"HTML-документ, добавив теги <html> или <body>. "

#: ../../bs4ru.rst:2721
msgid ""
"Since the document \"<a></p>\" is invalid, none of these techniques is "
"the 'correct' way to handle it. The html5lib parser uses techniques that "
"are part of the HTML5 standard, so it has the best claim on being the "
"'correct' way, but all three techniques are legitimate."
msgstr ""
"Поскольку документ ``<a></p>`` невалиден, ни один из этих способов нельзя"
" назвать \"правильным\". Парсер html5lib использует способы, которые "
"являются частью стандарта HTML5, поэтому он может претендовать на то, что"
" его подход самый \"правильный\", но правомерно использовать любой из "
"трех методов. "

#: ../../bs4ru.rst:2726
msgid ""
"Differences between parsers can affect your script. If you're planning on"
" distributing your script to other people, or running it on multiple "
"machines, you should specify a parser in the :py:class:`BeautifulSoup` "
"constructor. That will reduce the chances that your users parse a "
"document differently from the way you parse it."
msgstr ""
"Различия между парсерами могут повлиять на ваш скрипт. Если вы планируете"
" распространять ваш скрипт или запускать его на нескольких машинах, вам "
"нужно указать парсер в конструкторе :py:class:`BeautifulSoup`. Это "
"уменьшит вероятность того, что ваши пользователи при разборе документа "
"получат результат, отличный от вашего. "

#: ../../bs4ru.rst:2733
msgid "Encodings"
msgstr "Кодировки "

#: ../../bs4ru.rst:2735
msgid ""
"Any HTML or XML document is written in a specific encoding like ASCII or "
"UTF-8. But when you load that document into Beautiful Soup, you'll "
"discover it's been converted to Unicode::"
msgstr ""
"Любой документ HTML или XML написан в определенной кодировке, такой как "
"ASCII или UTF-8.  Но когда вы загрузите этот документ в Beautiful Soup, "
"вы обнаружите, что он был преобразован в Unicode:: "

#: ../../bs4ru.rst:2746
msgid ""
"It's not magic. (That sure would be nice.) Beautiful Soup uses a sub-"
"library called `Unicode, Dammit`_ to detect a document's encoding and "
"convert it to Unicode. The autodetected encoding is available as the "
"``.original_encoding`` attribute of the :py:class:`BeautifulSoup` "
"object::"
msgstr ""
"Это не волшебство. (Хотя это было бы здорово, конечно.) Beautiful Soup "
"использует подбиблиотеку под названием `Unicode, Dammit`_ для определения"
" кодировки документа и преобразования ее в Unicode. Кодировка, которая "
"была автоматически определена, содержится в значении атрибута "
"``.original_encoding`` объекта :py:class:`BeautifulSoup`:: "

#: ../../bs4ru.rst:2754
msgid ""
"If ``.original_encoding`` is ``None``, that means the document was "
"already Unicode when it was passed into Beautiful Soup::"
msgstr ""
"Если ``.original_encoding`` имеет значение ``None``, это означает, что, когда документ передали в Beautiful Soup, он уже был в  кодировке Unicode::"

#: ../../bs4ru.rst:2762
msgid ""
"Unicode, Dammit guesses correctly most of the time, but sometimes it "
"makes mistakes. Sometimes it guesses correctly, but only after a byte-by-"
"byte search of the document that takes a very long time. If you happen to"
" know a document's encoding ahead of time, you can avoid mistakes and "
"delays by passing it to the :py:class:`BeautifulSoup` constructor as "
"``from_encoding``."
msgstr ""
"Unicode, Dammit чаще всего угадывает правильно, но иногда делает ошибки. "
"Иногда он угадывает правильно только после побайтового поиска по "
"документу, что занимает очень много времени. Если вы вдруг уже знаете "
"кодировку документа, вы можете избежать ошибок и задержек, передав "
"кодировку конструктору :py:class:`BeautifulSoup` как аргумент "
"``from_encoding``. "

#: ../../bs4ru.rst:2769
msgid ""
"Here's a document written in ISO-8859-8. The document is so short that "
"Unicode, Dammit can't get a lock on it, and misidentifies it as "
"ISO-8859-7::"
msgstr ""
"Вот документ, написанный на ISO-8859-8. Документ настолько короткий, что "
"Unicode, Dammit не может разобраться и неправильно идентифицирует "
"кодировку как ISO-8859-7:: "

#: ../../bs4ru.rst:2780
msgid "We can fix this by passing in the correct ``from_encoding``::"
msgstr "Мы можем все исправить, передав правильный ``from_encoding``:: "

#: ../../bs4ru.rst:2788
msgid ""
"If you don't know what the correct encoding is, but you know that "
"Unicode, Dammit is guessing wrong, you can pass the wrong guesses in as "
"``exclude_encodings``::"
msgstr ""
"Если вы не знаете правильную кодировку, но видите, что Unicode, Dammit "
"определяет ее неправильно, вы можете передать ошибочные варианты в "
"``exclude_encodings``:: "

#: ../../bs4ru.rst:2798
#, python-format
msgid ""
"Windows-1255 isn't 100% correct, but that encoding is a compatible "
"superset of ISO-8859-8, so it's close enough. (``exclude_encodings`` is a"
" new feature in Beautiful Soup 4.4.0.)"
msgstr ""
"Windows-1255 не на 100% подходит, но это совместимое надмножество "
"ISO-8859-8, так что догадка почти верна. (``exclude_encodings`` — это "
"новая функция в Beautiful Soup 4.4.0.) "

#: ../../bs4ru.rst:2802
msgid ""
"In rare cases (usually when a UTF-8 document contains text written in a "
"completely different encoding), the only way to get Unicode may be to "
"replace some characters with the special Unicode character \"REPLACEMENT "
"CHARACTER\" (U+FFFD, �). If Unicode, Dammit needs to do this, it will set"
" the ``.contains_replacement_characters`` attribute to ``True`` on the "
"``UnicodeDammit`` or :py:class:`BeautifulSoup` object. This lets you know"
" that the Unicode representation is not an exact representation of the "
"original—some data was lost. If a document contains �, but "
"``.contains_replacement_characters`` is ``False``, you'll know that the �"
" was there originally (as it is in this paragraph) and doesn't stand in "
"for missing data."
msgstr ""
"В редких случаях (обычно когда документ UTF-8 содержит текст в совершенно"
" другой кодировке) единственным способом получить Unicode может оказаться"
" замена некоторых символов специальным символом Unicode\"REPLACEMENT "
"CHARACTER\" (U+FFFD, �). Если Unicode, Dammit приходится это сделать, он "
"установит атрибут ``.contains_replacement_characters`` в ``True`` для "
"объектов ``UnicodeDammit`` или :py:class:`BeautifulSoup`. Это даст "
"понять, что представление в виде Unicode не является точным представление"
" оригинала, и что некоторые данные потерялись. Если документ содержит �, "
"но ``.contains_replacement_characters`` равен ``False``, вы будете знать,"
" что � был в тексте изначально (как в этом параграфе), а не служит "
"заменой отсутствующим данным. "

#: ../../bs4ru.rst:2815
msgid "Output encoding"
msgstr "Кодировка вывода "

#: ../../bs4ru.rst:2817
msgid ""
"When you write out an output document from Beautiful Soup, you get a "
"UTF-8 document, even if the input document wasn't in UTF-8 to begin with."
" Here's a document written in the Latin-1 encoding::"
msgstr ""
"Когда вы пишете документ из Beautiful Soup, вы получаете документ в "
"UTF-8, даже если он изначально не был в UTF-8. Вот документ в кодировке "
"Latin-1:: "

#: ../../bs4ru.rst:2845
msgid ""
"Note that the <meta> tag has been rewritten to reflect the fact that the "
"document is now in UTF-8."
msgstr ""
"Обратите внимание, что тег <meta> был переписан, чтобы отразить тот факт,"
" что теперь документ кодируется в UTF-8. "

#: ../../bs4ru.rst:2848
msgid "If you don't want UTF-8, you can pass an encoding into ``prettify()``::"
msgstr ""
"Если вы не хотите кодировку UTF-8, вы можете передать другую в "
"``prettify()``:: "

#: ../../bs4ru.rst:2856
msgid ""
"You can also call encode() on the :py:class:`BeautifulSoup` object, or "
"any element in the soup, just as if it were a Python string::"
msgstr ""
"Вы также можете вызвать encode() для объекта :py:class:`BeautifulSoup` "
"или любого элемента в супе, как если бы это была строка Python:: "

#: ../../bs4ru.rst:2865
msgid ""
"Any characters that can't be represented in your chosen encoding will be "
"converted into numeric XML entity references. Here's a document that "
"includes the Unicode character SNOWMAN::"
msgstr ""
"Любые символы, которые не могут быть представлены в выбранной вами "
"кодировке, будут преобразованы в числовые коды мнемоник XML. Вот "
"документ, который включает в себя Unicode-символ SNOWMAN (снеговик):: "

#: ../../bs4ru.rst:2873
msgid ""
"The SNOWMAN character can be part of a UTF-8 document (it looks like ☃), "
"but there's no representation for that character in ISO-Latin-1 or ASCII,"
" so it's converted into \"&#9731\" for those encodings::"
msgstr ""
"Символ SNOWMAN может быть частью документа UTF-8 (он выглядит так: ☃), но"
" в ISO-Latin-1 или ASCII нет представления для этого символа, поэтому для"
" этих кодировок он конвертируется в \"&#9731;\":: "

#: ../../bs4ru.rst:2887
msgid "Unicode, Dammit"
msgstr "Unicode, Dammit "

#: ../../bs4ru.rst:2889
msgid ""
"You can use Unicode, Dammit without using Beautiful Soup. It's useful "
"whenever you have data in an unknown encoding and you just want it to "
"become Unicode::"
msgstr ""
"Вы можете использовать Unicode, Dammit без Beautiful Soup. Он полезен в "
"тех случаях, когда у вас есть данные в неизвестной кодировке, и вы просто"
" хотите, чтобы они преобразовались в Unicode:: "

#: ../../bs4ru.rst:2900
msgid ""
"Unicode, Dammit's guesses will get a lot more accurate if you install one"
" of these Python libraries: ``charset-normalizer``, ``chardet``, or "
"``cchardet``. The more data you give Unicode, Dammit, the more accurately"
" it will guess. If you have your own suspicions as to what the encoding "
"might be, you can pass them in as a list::"
msgstr ""
"Догадки Unicode, Dammit станут намного точнее, если вы установите "
"библиотеки Python ``charset-normalizer``, ``chardet`` или ``cchardet``. "
"Чем больше данных вы даете Unicode, Dammit, тем точнее он определит "
"кодировку. Если у вас есть собственные предположения относительно "
"возможных кодировок, вы можете передать их в виде списка:: "

#: ../../bs4ru.rst:2912
msgid "Unicode, Dammit has two special features that Beautiful Soup doesn't use."
msgstr ""
"В Unicode, Dammit есть две специальные функции, которые Beautiful Soup не"
" использует. "

#: ../../bs4ru.rst:2916
msgid "Smart quotes"
msgstr "Парные кавычки "

#: ../../bs4ru.rst:2918
msgid ""
"You can use Unicode, Dammit to convert Microsoft smart quotes to HTML or "
"XML entities::"
msgstr ""
"Вы можете использовать Unicode, Dammit, чтобы конвертировать парные "
"кавычки (Microsoft smart quotes) в мнемоники HTML или XML:: "

#: ../../bs4ru.rst:2929
msgid "You can also convert Microsoft smart quotes to ASCII quotes::"
msgstr "Вы также можете конвертировать парные кавычки в обычные кавычки ASCII:: "

#: ../../bs4ru.rst:2934
msgid ""
"Hopefully you'll find this feature useful, but Beautiful Soup doesn't use"
" it. Beautiful Soup prefers the default behavior, which is to convert "
"Microsoft smart quotes to Unicode characters along with everything else::"
msgstr ""
"Надеюсь, вы найдете эту функцию полезной, но Beautiful Soup не использует"
" ее. Beautiful Soup по умолчанию конвертирует парные кавычки в символы "
"Unicode, как и все остальное:: "

#: ../../bs4ru.rst:2943
msgid "Inconsistent encodings"
msgstr "Несогласованные кодировки "

#: ../../bs4ru.rst:2945
msgid ""
"Sometimes a document is mostly in UTF-8, but contains Windows-1252 "
"characters such as (again) Microsoft smart quotes. This can happen when a"
" website includes data from multiple sources. You can use "
"``UnicodeDammit.detwingle()`` to turn such a document into pure UTF-8. "
"Here's a simple example::"
msgstr ""
"Иногда документ кодирован в основном в UTF-8, но содержит символы "
"Windows-1252, такие как, опять-таки, парные кавычки. Такое бывает, когда "
"веб-сайт содержит данные из нескольких источников. Вы можете использовать"
" ``UnicodeDammit.detwingle()``, чтобы превратить такой документ в чистый "
"UTF-8. Вот простой пример:: "

#: ../../bs4ru.rst:2955
msgid ""
"This document is a mess. The snowmen are in UTF-8 and the quotes are in "
"Windows-1252. You can display the snowmen or the quotes, but not both::"
msgstr ""
"В этом документе бардак. Снеговики в UTF-8, а парные кавычки в "
"Windows-1252. Можно отображать или снеговиков, или кавычки, но не то и "
"другое одновременно:: "

#: ../../bs4ru.rst:2965
msgid ""
"Decoding the document as UTF-8 raises a ``UnicodeDecodeError``, and "
"decoding it as Windows-1252 gives you gibberish. Fortunately, "
"``UnicodeDammit.detwingle()`` will convert the string to pure UTF-8, "
"allowing you to decode it to Unicode and display the snowmen and quote "
"marks simultaneously::"
msgstr ""
"Декодирование документа как UTF-8 вызывает ``UnicodeDecodeError``, а "
"декодирование его как Windows-1252 выдаст тарабарщину. К счастью, "
"``UnicodeDammit.detwingle()`` преобразует строку в чистый UTF-8, позволяя"
" затем декодировать его в Unicode и отображать снеговиков и кавычки "
"одновременно:: "

#: ../../bs4ru.rst:2975
msgid ""
"``UnicodeDammit.detwingle()`` only knows how to handle Windows-1252 "
"embedded in UTF-8 (or vice versa, I suppose), but this is the most common"
" case."
msgstr ""
"``UnicodeDammit.detwingle()`` знает только, как обрабатывать "
"Windows-1252, встроенный в UTF-8 (и наоборот, мне кажется), но это "
"наиболее общий случай. "

#: ../../bs4ru.rst:2979
msgid ""
"Note that you must know to call ``UnicodeDammit.detwingle()`` on your "
"data before passing it into :py:class:`BeautifulSoup` or the "
"``UnicodeDammit`` constructor. Beautiful Soup assumes that a document has"
" a single encoding, whatever it might be. If you pass it a document that "
"contains both UTF-8 and Windows-1252, it's likely to think the whole "
"document is Windows-1252, and the document will come out looking like "
"``â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”``."
msgstr ""
"Обратите внимание, что нужно вызывать ``UnicodeDammit.detwingle()`` для "
"ваших данных перед передачей в конструктор :py:class:`BeautifulSoup` или "
"``UnicodeDammit``. Beautiful Soup предполагает, что документ имеет единую"
" кодировку, какой бы она ни была. Если вы передадите ему документ, "
"который содержит как UTF-8, так и Windows-1252, скорее всего, он решит, "
"что весь документ кодируется в Windows-1252, и это будет выглядеть как "
"``â˜ƒâ˜ƒâ˜ƒ“I like snowmen!”``. "

#: ../../bs4ru.rst:2987
msgid "``UnicodeDammit.detwingle()`` is new in Beautiful Soup 4.1.0."
msgstr "``UnicodeDammit.detwingle()`` — это новое в Beautiful Soup 4.1.0. "

#: ../../bs4ru.rst:2990
msgid "Line numbers"
msgstr "Нумерация строк "

#: ../../bs4ru.rst:2992
msgid ""
"The ``html.parser`` and ``html5lib`` parsers can keep track of where in "
"the original document each :py:class:`Tag` was found. You can access this"
" information as ``Tag.sourceline`` (line number) and ``Tag.sourcepos`` "
"(position of the start tag within a line)::"
msgstr ""
"Парсеры ``html.parser`` и ``html5lib`` могут отслеживать, где в исходном "
"документе был найден каждый :py:class:`Tag`. Вы можете получить доступ к "
"этой информации через ``Tag.sourceline`` (номер строки) и "
"``Tag.sourcepos`` (позиция начального тега в строке):: "

#: ../../bs4ru.rst:3004
msgid ""
"Note that the two parsers mean slightly different things by "
"``sourceline`` and ``sourcepos``. For html.parser, these numbers "
"represent the position of the initial less-than sign. For html5lib, these"
" numbers represent the position of the final greater-than sign::"
msgstr ""
"Обратите внимание, что два парсера понимают ``sourceline`` и "
"``sourcepos`` немного по-разному. Для html.parser эти числа представляет "
"позицию начального знака \"<\". Для html5lib эти числа представляют "
"позицию конечного знака \">\":: "

#: ../../bs4ru.rst:3015
msgid ""
"You can shut off this feature by passing ``store_line_numbers=False`` "
"into the :py:class:`BeautifulSoup` constructor::"
msgstr ""
"Вы можете отключить эту функцию, передав ``store_line_numbers = False`` в"
" конструктор :py:class:`BeautifulSoup`:: "

#: ../../bs4ru.rst:3023
msgid ""
"*This feature is new in 4.8.1, and the parsers based on lxml don't "
"support it.*"
msgstr ""
"*Эта функция является новой в 4.8.1, и парсеры, основанные на lxml, не "
"поддерживают ее.*"

#: ../../bs4ru.rst:3027
msgid "Comparing objects for equality"
msgstr "Проверка объектов на равенство "

#: ../../bs4ru.rst:3029
msgid ""
"Beautiful Soup says that two :py:class:`NavigableString` or "
":py:class:`Tag` objects are equal when they represent the same HTML or "
"XML markup, even if their attributes are in a different order or they "
"live in different parts of the object tree. In this example, the two <b> "
"tags are treated as equal, because they both look like \"<b>pizza</b>\"::"
msgstr ""
"Beautiful Soup считает, что два объекта :py:class:`NavigableString` или "
":py:class:`Tag` равны, если они представлены в одинаковой разметке HTML "
"или XML, даже если их атрибуты расположены в другом порядке или они сами "
"находятся в разных частях дерева объекта. В этом примере два тега <b> "
"рассматриваются как равные, потому что они оба выглядят как "
"``<b>pizza</b>``:: "

#: ../../bs4ru.rst:3044
msgid ""
"If you want to see whether two variables refer to exactly the same "
"object, use *is*::"
msgstr ""
"Если вы хотите выяснить, указывают ли две переменные на один и тот же "
"объект, используйте *is*:: "

#: ../../bs4ru.rst:3051
msgid "Copying Beautiful Soup objects"
msgstr "Копирование объектов Beautiful Soup "

#: ../../bs4ru.rst:3053
msgid ""
"You can use ``copy.copy()`` to create a copy of any :py:class:`Tag` or "
":py:class:`NavigableString`::"
msgstr ""
"Вы можете использовать ``copy.copy()`` для создания копии любого "
":py:class:`Tag` или :py:class:`NavigableString`:: "

#: ../../bs4ru.rst:3061
msgid ""
"The copy is considered equal to the original, since it represents the "
"same markup as the original, but it's not the same object::"
msgstr ""
"Копия считается равной оригиналу, так как у нее такая же разметка, что и "
"у оригинала, но это другой объект:: "

#: ../../bs4ru.rst:3070
msgid ""
"The only real difference is that the copy is completely detached from the"
" original Beautiful Soup object tree, just as if ``extract()`` had been "
"called on it. This is because two different :py:class:`Tag` objects can't"
" occupy the same space at the same time."
msgstr ""
"Разница в том, что копия полностью отделена от "
"исходного дерева объекта Beautiful Soup, как если бы в отношении нее "
"вызвали метод  ``extract()``. Это связано с тем, что два разных объекта :py:class:`Tag` "
"не могут одновременно занимать одно и то же пространство."

#: ../../bs4ru.rst:3080
msgid ""
"You can use :py:meth:`Tag.copy_self` to create a copy of a "
":py:class:`Tag` without copying its contents."
msgstr ""
"Вы можете использовать :py:meth:`Tag.copy_self`, чтобы создать копию "
":py:class:`Tag`, не копируя его содержимое."

#: ../../bs4ru.rst:3091
msgid "*(Tag.copy_self() is introduced in Beautiful Soup 4.13.0.)*"
msgstr "*(Tag.copy_self() введен в Beautiful Soup 4.13.0.)*"

#: ../../bs4ru.rst:3095
msgid "Low-level search interface"
msgstr ""
"Низкоуровневый интерфейс поиска"

#: ../../bs4ru.rst:3097
msgid ""
"Almost everyone who uses Beautiful Soup to extract information from a "
"document can get what they need using the methods described in `Searching"
" the tree`_. However, there's a lower-level interface that lets you "
"define any matching behavior you want. Behind the scenes, the parts of "
"the Beautiful Soup API that most people use--``find_all()`` and the "
"like—are actually using this low-level interface, and you can use it "
"directly."
msgstr ""
"Почти все, кто использует Beautiful Soup для извлечения информации из документа, "
"могут получить всё необходимое, используя методы, описанные в разделе `Поиск по дереву`_. "
"Однако есть низкоуровневый интерфейс, который позволяет вам задать любое желаемое поведение для сопоставляемых элементов. "
"Те части API Beautiful Soup, которые использует большинство людей "
"— ``find_all()`` и другие — на самом деле под капотом используют этот низкоуровневый интерфейс. "
"Вы можете использовать его напрямую."

#: ../../bs4ru.rst:3105
msgid ""
"*(Access to the low-level search interface is a new feature in Beautiful "
"Soup 4.13.0.)*"
msgstr "*(Доступ к низкоуровневому интерфейсу поиска — это новая возможность в Beautiful Soup 4.13.0.)*"

#: ../../bs4ru.rst:3109
msgid "Custom element filtering"
msgstr ""
"Настраиваемая фильтрация элементов"

#: ../../bs4ru.rst:3113
msgid ""
"The :py:class:`ElementFilter` class is your entry point to the low-level "
"interface. To use it, define a function that takes a "
":py:class:`PageElement` object (which could be either a :py:class:`Tag` "
"or a :py:class:`NavigableString`). The function must return ``True`` if "
"the element matches your custom criteria, and ``False`` if it doesn't."
msgstr ""
"Ваша точка входа в низкоуровневый интерфейс -- это класс :py:class:`ElementFilter`. "
"Чтобы использовать его, определите функцию, которая принимает объект :py:class:`PageElement`. "
"Этот объект может быть либо :py:class:`Tag`, либо :py:class:`NavigableString`. "
"Функция должна возвращать ``True``, если элемент соответствует вашим пользовательским критериям, и ``False``, если нет."

#: ../../bs4ru.rst:3120
msgid ""
"This example function looks for content-containing tags and strings, but "
"skips whitespace-only strings::"
msgstr ""
"Функция в примере ниже ищет теги и строки, в которых есть содержимое, и пропускает строки, состоящие только из пробелов::"

#: ../../bs4ru.rst:3135
msgid ""
"Once you have a function, pass it into the :py:class:`ElementFilter` "
"constructor::"
msgstr ""
"Когда ваша функция готова, передайте ее в конструктор :py:class:`ElementFilter`::"

#: ../../bs4ru.rst:3140
msgid ""
"You can then use this :py:class:`ElementFilter` object as the first "
"argument to any of the `Searching the tree`_ methods. Whatever criteria "
"you defined in your function will be used instead of the default "
"Beautiful Soup match logic::"
msgstr ""
"Затем вы можете использовать этот объект :py:class:`ElementFilter` "
"в качестве первого аргумента для любого из методов, описанных в разделе `Поиск по дереву`_. "
"Критерий, который вы определили в своей функции,  "
"будет использоваться вместо той логики сопоставления, которая действует в Beautiful Soup по умолчанию::"

#: ../../bs4ru.rst:3165
msgid ""
"Every potential match will be run through your function, and the only "
":py:class:`PageElement` objects returned will be the ones where your "
"function returned ``True``."
msgstr ""
"Каждое потенциальное совпадение будет пропущено через вашу функцию, "
"а возвращаться будут те объекты :py:class:`PageElement`, "
"для которых ваша функция вернула ``True``."

#: ../../bs4ru.rst:3169
msgid "To summarize the function-based matching behaviors,"
msgstr ""
"Подведем итог."

#: ../../bs4ru.rst:3171
msgid ""
"A function passed as the first argument to a search method (or "
"equivalently, using the ``name`` argument) considers only :py:class:`Tag`"
" objects."
msgstr ""
"Функция, переданная в качестве первого аргумента методу поиска "
"(или, что эквивалентно, с использованием аргумента ``name``), учитывает только объекты :py:class:`Tag`."

#: ../../bs4ru.rst:3174
msgid ""
"A function passed to a search method using the ``string`` argument "
"considers only :py:class:`NavigableString` objects."
msgstr ""
"Функция, переданная методу поиска с использованием аргумента ``string``, учитывает только объекты :py:class:`NavigableString`."

#: ../../bs4ru.rst:3176
msgid ""
"A function passed to a search method using an :py:class:`ElementFilter` "
"object considers both :py:class:`Tag` and :py:class:`NavigableString` "
"objects."
msgstr ""
"Функция, переданная методу поиска с использованием объекта :py:class:`ElementFilter`, учитывает как объекты :py:class:`Tag`, так и :py:class:`NavigableString`."

#: ../../bs4ru.rst:3181
msgid "Custom element iteration"
msgstr ""
"Настраиваемый перебор элементов"

#: ../../bs4ru.rst:3185
msgid ""
"By passing an :py:class:`ElementFilter` instance into Beautiful Soup's "
"tree-searching methods, you can completely customize what it means for "
"Beautiful Soup to match an element as it iterates over the parse tree. By"
" using the :py:meth:`ElementFilter.filter()` method, you can also "
"completely customize what it means for Beautiful Soup to iterate over the"
" parse tree in the first place."
msgstr ""
"Передавая экземпляр :py:class:`ElementFilter` в методы поиска по дереву Beautiful Soup, "
"вы можете полностью настроить, как Beautiful Soup должен сопоставлять элементы при проходе по дереву разбора. "
"Используя метод :py:meth:`ElementFilter.filter()`, вы также можете полностью настроить, "
"как именно Beautiful Soup должен проходить по дереву разбора."

#: ../../bs4ru.rst:3192
msgid ""
"The :py:meth:`ElementFilter.filter()` method takes a generator that "
"yields a stream of :py:class:`PageElement` objects. There is no "
"restriction on which :py:class:`PageElement` objects show up, how many "
"times they show up, or in which order. Theoretically, they don't even "
"need to be from the same :py:class:`BeautifulSoup` document. You can do "
"whatever makes sense for you."
msgstr ""
"Метод :py:meth:`ElementFilter.filter()` принимает генератор, который "
"выдает поток объектов :py:class:`PageElement`. Нет никаких ограничений на то, "
"какие объекты :py:class:`PageElement` будут отображаться, сколько раз "
"они будут отображаться или в каком порядке. "
"Теоретически, они даже не обязательно должны быть из одного и того же "
"документа :py:class:`BeautifulSoup`. Вы можете делать все, что сочтете нужным."

#: ../../bs4ru.rst:3199
msgid ""
"Here's a silly example: a generator that walks randomly back and forth "
"through the parse tree::"
msgstr ""
"Вот дурацкий пример: генератор, который в случайном порядке ходит туда-сюда по дереву разбора::"

#: ../../bs4ru.rst:3214
msgid ""
"Pass this generator into the example :py:meth:`ElementFilter.filter()` "
"and Beautiful Soup will wander randomly around the parse tree, applying "
"the ``non_whitespace_filter`` function to every element it finds, and "
"yielding all of the matches—potentially yielding a given object more than"
" once::"
msgstr ""
"Передайте этот генератор в :py:meth:`ElementFilter.filter()`, "
"и Beautiful Soup будет в случайном порядке проходить по дереву разбора, "
"применяя функцию ``non_whitespace_filter`` к каждому найденному элементу "
"и выдавая все совпадения, в том числе потенциально выдавая заданный объект более одного раза::"

#: ../../bs4ru.rst:3226
msgid ""
"(Note that unlike the other code examples in this documentation, this "
"example can give different results every time you run it, thanks to the "
"random element. It's very unlikely, but this function could wander around"
" the parse tree forever and *never* complete.)"
msgstr ""
"(В отличие от других примеров кода в этой документации, "
"этот пример может выдавать разные результаты каждый раз, когда вы его запускаете, "
"благодаря элементу случайности. Это очень маловероятно, но такая функция "
"может бродить по дереву разбора вечно и *никогда* не завершиться.)"

#: ../../bs4ru.rst:3232
msgid "Advanced parser customization"
msgstr "Расширенная настройка парсера "

#: ../../bs4ru.rst:3234
msgid ""
"Beautiful Soup offers a number of ways to customize how the parser treats"
" incoming HTML and XML. This section covers the most commonly used "
"customization techniques."
msgstr ""
"Beautiful Soup предлагает несколько способов настроить то, как парсер "
"обрабатывает входящий HTML и XML. Этот раздел охватывает наиболее часто "
"используемые методы настройки. "

#: ../../bs4ru.rst:3239
msgid "Parsing only part of a document"
msgstr "Разбор части документа "

#: ../../bs4ru.rst:3241
msgid ""
"Let's say you want to use Beautiful Soup to look at a document's <a> "
"tags. It's a waste of time and memory to parse the entire document and "
"then go over it again looking for <a> tags. It would be much faster to "
"ignore everything that wasn't an <a> tag in the first place. The "
":py:class:`SoupStrainer` class allows you to choose which parts of an "
"incoming document are parsed. You just create a :py:class:`SoupStrainer` "
"and pass it in to the :py:class:`BeautifulSoup` constructor as the "
"``parse_only`` argument."
msgstr ""
"Допустим, вы хотите использовать Beautiful Soup, чтобы посмотреть на теги"
" <a> в документе. Было бы бесполезной тратой времени и памяти разбирать "
"весь документ и затем снова проходить по нему в поисках тегов <a>. "
"Намного быстрее изначательно игнорировать все, что не является тегом <a>."
" Класс :py:class:`SoupStrainer` позволяет выбрать, какие части входящего "
"документа разбирать. Вы просто создаете :py:class:`SoupStrainer` и "
"передаете его в конструктор :py:class:`BeautifulSoup` в качестве "
"аргумента ``parse_only``. "

#: ../../bs4ru.rst:3249
msgid ""
"(Note that *this feature won't work if you're using the html5lib parser*."
" If you use html5lib, the whole document will be parsed, no matter what. "
"This is because html5lib constantly rearranges the parse tree as it "
"works, and if some part of the document didn't actually make it into the "
"parse tree, it'll crash. To avoid confusion, in the examples below I'll "
"be forcing Beautiful Soup to use Python's built-in parser.)"
msgstr ""
"(Обратите внимание, что *эта функция не будет работать, если вы "
"используете парсер html5lib*. Если вы используете html5lib, будет "
"разобран весь документ, независимо от обстоятельств. Это потому что "
"html5lib постоянно переставляет части дерева разбора в процессе работы, и"
" если какая-то часть документа не попала в дерево разбора, все рухнет. "
"Чтобы избежать путаницы, в примерах ниже я принудительно использую "
"встроенный в Python парсер HTML.) "

#: ../../bs4ru.rst:3259
msgid ""
"The :py:class:`SoupStrainer` class takes the same arguments as a typical "
"method from `Searching the tree`_: :ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>`, and :ref:`**kwargs <kwargs>`. Here are "
"three :py:class:`SoupStrainer` objects::"
msgstr ""
"Класс :py:class:`SoupStrainer` принимает те же аргументы, что и типичный "
"метод из раздела `Поиск по дереву`_: :ref:`name <name>`, :ref:`attrs "
"<attrs>`, :ref:`string <string>` и :ref:`**kwargs <kwargs>`. Вот три "
"объекта :py:class:`SoupStrainer`:: "

#: ../../bs4ru.rst:3275
msgid ""
"I'm going to bring back the \"three sisters\" document one more time, and"
" we'll see what the document looks like when it's parsed with these three"
" :py:class:`SoupStrainer` objects::"
msgstr ""
"Вернемся к фрагменту из «Алисы в стране чудес» и увидим, как выглядит "
"документ, когда он разобран с этими тремя объектами "
":py:class:`SoupStrainer`:: "

#: ../../bs4ru.rst:3317
msgid "The :py:class:`SoupStrainer` behavior is as follows:"
msgstr "Поведение :py:class:`SoupStrainer` выглядит следующим образом:"

#: ../../bs4ru.rst:3319
msgid ""
"When a tag matches, it is kept (including all its contents, whether they "
"also match or not)."
msgstr ""
"Если тег совпадает, он сохраняется (включая все его содержимое, "
"независимо от того, подходит оно или нет)."

#: ../../bs4ru.rst:3321
msgid ""
"When a tag does not match, the tag itself is not kept, but parsing "
"continues into its contents to look for other tags that do match."
msgstr ""
"Если тег не подходит, сам тег не сохраняется, но анализ его содержимого "
"продолжается для поиска других тегов, которые подходят."

#: ../../bs4ru.rst:3326
msgid "Customizing multi-valued attributes"
msgstr "Настройка многозначных атрибутов "

#: ../../bs4ru.rst:3328
msgid ""
"In an HTML document, an attribute like ``class`` is given a list of "
"values, and an attribute like ``id`` is given a single value, because the"
" HTML specification treats those attributes differently::"
msgstr ""
"В документе HTML атрибуту вроде ``class`` присваивается список значений, "
"а атрибуту вроде ``id`` присваивается одно значение, потому что "
"спецификация HTML трактует эти атрибуты по-разному:: "

#: ../../bs4ru.rst:3339
msgid ""
"You can turn this off by passing in ``multi_valued_attributes=None``. "
"Than all attributes will be given a single value::"
msgstr ""
"Вы можете отключить многозначные атрибуты, передав "
"``multi_valued_attributes=None``. Все атрибуты получат единственное "
"значение:: "

#: ../../bs4ru.rst:3349
msgid ""
"You can customize this behavior quite a bit by passing in a dictionary "
"for ``multi_valued_attributes``. If you need this, look at "
"``HTMLTreeBuilder.DEFAULT_CDATA_LIST_ATTRIBUTES`` to see the "
"configuration Beautiful Soup uses by default, which is based on the HTML "
"specification."
msgstr ""
"Вы можете слегка изменить это поведение, передав в "
"``multi_valued_attributes`` словарь. Если вам это нужно, взгляните на "
"``HTMLTreeBuilder.DEFAULT_CDATA_LIST_ATTRIBUTES``, чтобы увидеть "
"конфигурацию Beautiful Soup, которая  используется по умолчанию и которая"
" основана на спецификации HTML. "

#: ../../bs4ru.rst:3355
msgid "*(This is a new feature in Beautiful Soup 4.8.0.)*"
msgstr "*(Это новая функция в Beautiful Soup 4.8.0.)*"

#: ../../bs4ru.rst:3358
msgid "Handling duplicate attributes"
msgstr "Обработка дублирующих атрибутов "

#: ../../bs4ru.rst:3360
msgid ""
"When using the ``html.parser`` parser, you can use the "
"``on_duplicate_attribute`` constructor argument to customize what "
"Beautiful Soup does when it encounters a tag that defines the same "
"attribute more than once::"
msgstr ""
"С парсером ``html.parser`` вы можете использовать в конструкторе аргумент"
" ``on_duplicate_attribute``. С помощью этого аргумента можно указать "
"Beautiful Soup, что следует делать с тегом, в котором более одного раза "
"определен один и тот же атрибут:: "

#: ../../bs4ru.rst:3367
msgid "The default behavior is to use the last value found for the tag::"
msgstr ""
"Поведение по умолчанию — использовать последнее найденное в теге "
"значение:: "

#: ../../bs4ru.rst:3377
msgid ""
"With ``on_duplicate_attribute='ignore'`` you can tell Beautiful Soup to "
"use the *first* value found and ignore the rest::"
msgstr ""
"С помощью ``on_duplicate_attribute = 'ignore'`` вы можете указать "
"Beautiful Soup использовать *первое* найденное значение и игнорировать "
"остальные:: "

#: ../../bs4ru.rst:3384
msgid ""
"(lxml and html5lib always do it this way; their behavior can't be "
"configured from within Beautiful Soup.)"
msgstr ""
"(lxml и html5lib всегда делают это именно так; их поведение нельзя "
"изменить изнутри Beautiful Soup.) "

#: ../../bs4ru.rst:3387
msgid ""
"If you need more control, you can pass in a function that's called on "
"each duplicate value::"
msgstr ""
"Если вам нужно больше, вы можете передать функцию, которая вызывается для"
" каждого дублирующего значения:: "

#: ../../bs4ru.rst:3399
msgid "*(This is a new feature in Beautiful Soup 4.9.1.)*"
msgstr "*(Это новая функция в Beautiful Soup 4.9.1.)*"

#: ../../bs4ru.rst:3402
msgid "Instantiating custom subclasses"
msgstr "Создание пользовательских подклассов "

#: ../../bs4ru.rst:3404
msgid ""
"When a parser tells Beautiful Soup about a tag or a string, Beautiful "
"Soup will instantiate a :py:class:`Tag` or :py:class:`NavigableString` "
"object to contain that information. Instead of that default behavior, you"
" can tell Beautiful Soup to instantiate *subclasses* of :py:class:`Tag` "
"or :py:class:`NavigableString`, subclasses you define with custom "
"behavior::"
msgstr ""
"Когда парсер сообщает Beautiful Soup о теге или строке, Beautiful Soup "
"создает экземпляр объекта :py:class:`Tag` или "
":py:class:`NavigableString`, чтобы поместить туда эту информацию. Вместо "
"этого поведения по умолчанию вы можете указать Beautiful Soup создавать "
"экземпляр *подклассов* для :py:class:`Tag` или "
":py:class:`NavigableString`. Для этих подклассов вы определяете нужное "
"вам поведение:: "

#: ../../bs4ru.rst:3433
msgid ""
"This can be useful when incorporating Beautiful Soup into a test "
"framework."
msgstr "Это может быть полезно при включении Beautiful Soup в тестовый фреймворк. "

#: ../../bs4ru.rst:3436
msgid "*(This is a new feature in Beautiful Soup 4.8.1.)*"
msgstr "*(Это новая функция в Beautiful Soup 4.8.1.)*"

#: ../../bs4ru.rst:3439
msgid "Troubleshooting"
msgstr "Устранение неисправностей "

#: ../../bs4ru.rst:3444
msgid "``diagnose()``"
msgstr "``diagnose()`` "

#: ../../bs4ru.rst:3446
msgid ""
"If you're having trouble understanding what Beautiful Soup does to a "
"document, pass the document into the ``diagnose()`` function. (This "
"function is new in Beautiful Soup 4.2.0.) Beautiful Soup will print out a"
" report showing you how different parsers handle the document, and tell "
"you if you're missing a parser that Beautiful Soup could be using::"
msgstr ""
"Если у вас возникли проблемы с пониманием того, что Beautiful Soup делает"
" с документом, передайте документ в функцию ``Diagnose()``. (Новое в "
"Beautiful Soup 4.2.0.) Beautiful Soup выведет отчет, показывающий, как "
"разные парсеры обрабатывают документ, и сообщит вам, если отсутствует "
"парсер, который Beautiful Soup мог бы использовать:: "

#: ../../bs4ru.rst:3467
msgid ""
"Just looking at the output of diagnose() might show you how to solve the "
"problem. Even if not, you can paste the output of ``diagnose()`` when "
"asking for help."
msgstr ""
"Простой взгляд на вывод diagnose() может показать, как решить проблему. "
"Если это и не поможет, вы можете скопировать вывод ``Diagnose()``, когда "
"обратитесь за помощью. "

#: ../../bs4ru.rst:3472
msgid "Errors when parsing a document"
msgstr "Ошибки при разборе документа "

#: ../../bs4ru.rst:3474
msgid ""
"There are two different kinds of parse errors. There are crashes, where "
"you feed a document to Beautiful Soup and it raises an exception (usually"
" an ``HTMLParser.HTMLParseError``). And there is unexpected behavior, "
"where a Beautiful Soup parse tree looks a lot different than the document"
" used to create it."
msgstr ""
"Существует два вида ошибок разбора. Есть сбои, когда вы подаете документ "
"в Beautiful Soup, и это поднимает исключение, обычно "
"``HTMLParser.HTMLParseError``. И есть неожиданное поведение, когда дерево"
" разбора Beautiful Soup сильно отличается от документа, использованного "
"для создания дерева. "

#: ../../bs4ru.rst:3480
msgid ""
"These problems are almost never problems with Beautiful Soup itself. This"
" is not because Beautiful Soup is an amazingly well-written piece of "
"software. It's because Beautiful Soup doesn't include any parsing code. "
"Instead, it relies on external parsers. If one parser isn't working on a "
"certain document, the best solution is to try a different parser. See "
"`Installing a parser`_ for details and a parser comparison. If this "
"doesn't help, you might need to inspect the document tree found inside "
"the ``BeautifulSoup`` object, to see where the markup you're looking for "
"actually ended up."
msgstr ""
"Практически никогда источником этих проблемы не бывает Beautiful Soup. "
"Это не потому, что Beautiful Soup так прекрасно написан. Это потому, что "
"Beautiful Soup не содержит кода, который бы разбирал документ. Beautiful "
"Soup опирается на внешние парсеры. Если один парсер не подходит для "
"разбора документа, лучшим решением будет попробовать другой парсер. В "
"разделе `Установка парсера`_ вы найдете больше информации и таблицу "
"сравнения парсеров. "

#: ../../bs4ru.rst:3491
msgid "Version mismatch problems"
msgstr "Проблемы несоответствия версий "

#: ../../bs4ru.rst:3493
msgid ""
"``SyntaxError: Invalid syntax`` (on the line ``ROOT_TAG_NAME = "
"'[document]'``): Caused by running an old Python 2 version of Beautiful "
"Soup under Python 3, without converting the code."
msgstr ""
"``SyntaxError: Invalid syntax`` (в строке ``ROOT_TAG_NAME = "
"'[document]'``) — вызвано запуском устаревшей версии Beautiful Soup на "
"Python 2 под Python 3 без конвертации кода. "

#: ../../bs4ru.rst:3497
msgid ""
"``ImportError: No module named HTMLParser`` - Caused by running an old "
"Python 2 version of Beautiful Soup under Python 3."
msgstr ""
"``ImportError: No module named HTMLParser`` — вызвано запуском устаревшей"
" версии Beautiful Soup на Python 2 под Python 3. "

#: ../../bs4ru.rst:3500
msgid ""
"``ImportError: No module named html.parser`` - Caused by running the "
"Python 3 version of Beautiful Soup under Python 2."
msgstr ""
"``ImportError: No module named html.parser`` — вызвано запуском версии "
"Beautiful Soup на Python 3 под Python 2. "

#: ../../bs4ru.rst:3503
msgid ""
"``ImportError: No module named BeautifulSoup`` - Caused by running "
"Beautiful Soup 3 code in an environment that doesn't have BS3 installed. "
"Or, by writing Beautiful Soup 4 code without knowing that the package "
"name has changed to ``bs4``."
msgstr ""
"``ImportError: No module named BeautifulSoup`` — вызвано запуском кода "
"Beautiful Soup 3 в системе, где BS3 не установлен. Или код писали на "
"Beautiful Soup 4, не зная, что имя пакета сменилось на ``bs4``. "

#: ../../bs4ru.rst:3508
msgid ""
"``ImportError: No module named bs4`` - Caused by running Beautiful Soup 4"
" code in an environment that doesn't have BS4 installed."
msgstr ""
"``ImportError: No module named bs4`` — вызвано запуском кода Beautiful "
"Soup 4 в среде, где BS4 не установлен. "

#: ../../bs4ru.rst:3514
msgid "Parsing XML"
msgstr "Разбор XML "

#: ../../bs4ru.rst:3516
msgid ""
"By default, Beautiful Soup parses documents as HTML. To parse a document "
"as XML, pass in \"xml\" as the second argument to the "
":py:class:`BeautifulSoup` constructor::"
msgstr ""
"По умолчанию Beautiful Soup разбирает документы как HTML. Чтобы разобрать"
" документ в виде XML, передайте \"xml\" в качестве второго аргумента в "
"конструктор :py:class:`BeautifulSoup`:: "

#: ../../bs4ru.rst:3522
msgid "You'll need to :ref:`have lxml installed <parser-installation>`."
msgstr "Вам также нужно будет :ref:`установить lxml <parser-installation>`. "

#: ../../bs4ru.rst:3525
msgid "Other parser problems"
msgstr "Другие проблемы с парсерами "

#: ../../bs4ru.rst:3527
msgid ""
"If your script works on one computer but not another, or in one virtual "
"environment but not another, or outside the virtual environment but not "
"inside, it's probably because the two environments have different parser "
"libraries available. For example, you may have developed the script on a "
"computer that has lxml installed, and then tried to run it on a computer "
"that only has html5lib installed. See `Differences between parsers`_ for "
"why this matters, and fix the problem by mentioning a specific parser "
"library in the :py:class:`BeautifulSoup` constructor."
msgstr ""
"Если ваш скрипт работает на одном компьютере, но не работает на другом, "
"или работает в одной виртуальной среде, но не в другой, или работает вне "
"виртуальной среды, но не внутри нее, это, вероятно, потому что в двух "
"средах разные библиотеки парсеров. Например, вы могли разработать скрипт "
"на компьютере с установленным lxml, а затем попытались запустить его на "
"компьютере, где установлен только html5lib. Читайте в разделе `Различия "
"между парсерами`_, почему это важно, и исправляйте проблемы, указывая "
"конкретную библиотеку парсера в конструкторе :py:class:`BeautifulSoup`. "

#: ../../bs4ru.rst:3537
msgid ""
"Because `HTML tags and attributes are case-insensitive "
"<http://www.w3.org/TR/html5/syntax.html#syntax>`_, all three HTML parsers"
" convert tag and attribute names to lowercase. That is, the markup "
"<TAG></TAG> is converted to <tag></tag>. If you want to preserve mixed-"
"case or uppercase tags and attributes, you'll need to :ref:`parse the "
"document as XML. <parsing-xml>`"
msgstr ""
"Поскольку `HTML-теги и атрибуты нечувствительны к регистру "
"<http://www.w3.org/TR/html5/syntax.html#syntax>`_, все три HTML- парсера "
"конвертируют имена тегов и атрибутов в нижний регистр. Таким образом, "
"разметка <TAG></TAG> преобразуется в <tag></tag>. Если вы хотите "
"сохранить смешанный или верхний регистр тегов и атрибутов, вам нужно "
":ref:`разобрать документ как XML <parsing-xml>`. "

#: ../../bs4ru.rst:3547 ../../bs4ru.rst:3751
msgid "Miscellaneous"
msgstr "Прочие ошибки "

#: ../../bs4ru.rst:3549
msgid ""
"``UnicodeEncodeError: 'charmap' codec can't encode character '\\xfoo' in "
"position bar`` (or just about any other ``UnicodeEncodeError``) - This "
"problem shows up in two main situations. First, when you try to print a "
"Unicode character that your console doesn't know how to display. (See "
"`this page on the Python wiki <http://wiki.python.org/moin/PrintFails>`_ "
"for help.) Second, when you're writing to a file and you pass in a "
"Unicode character that's not supported by your default encoding. In this "
"case, the simplest solution is to explicitly encode the Unicode string "
"into UTF-8 with ``u.encode(\"utf8\")``."
msgstr ""
"``UnicodeEncodeError: 'charmap' codec can't encode character '\\xfoo' in "
"position bar`` (или практически любая другая ошибка "
"``UnicodeEncodeError``). Эта проблема проявляется в основном в двух "
"ситуациях. Во-первых, когда вы пытаетесь вывести символ Unicode, который "
"ваша консоль не может отобразить, потому что не знает, как. (Смотрите "
"`эту страницу в Python вики   "
"<http://wiki.python.org/moin/PrintFails>`_.) Во-вторых, когда вы пишете в"
" файл и передаете символ Unicode, который не поддерживается вашей "
"кодировкой по умолчанию. В этом случае самым простым решением будет явное"
" кодирование строки Unicode в UTF-8 с помощью ``u.encode(\"utf8\")``. "

#: ../../bs4ru.rst:3560
msgid ""
"``KeyError: [attr]`` - Caused by accessing ``tag['attr']`` when the tag "
"in question doesn't define the ``attr`` attribute. The most common errors"
" are ``KeyError: 'href'`` and ``KeyError: 'class'``. Use "
"``tag.get('attr')`` if you're not sure ``attr`` is defined, just as you "
"would with a Python dictionary."
msgstr ""
"``KeyError: [attr]`` — вызывается при обращении к ``tag['attr']``, когда "
"в искомом теге не определен атрибут ``attr``. Наиболее типичны ошибки "
"``KeyError: 'href'`` и ``KeyError: 'class'``. Используйте "
"``tag.get('attr')``, если вы не уверены, что ``attr`` определен — так же,"
" как если бы вы работали со словарем Python. "

#: ../../bs4ru.rst:3566
msgid ""
"``AttributeError: 'ResultSet' object has no attribute 'foo'`` - This "
"usually happens because you expected ``find_all()`` to return a single "
"tag or string. But ``find_all()`` returns a *list* of tags and strings—a "
"``ResultSet`` object. You need to iterate over the list and look at the "
"``.foo`` of each one. Or, if you really only want one result, you need to"
" use ``find()`` instead of ``find_all()``."
msgstr ""
"``AttributeError: 'ResultSet' object has no attribute 'foo'`` — это "
"обычно происходит тогда, когда вы ожидаете, что ``find_all()`` вернет "
"один тег или строку. Но ``find_all()`` возвращает *список* тегов и строк "
"в объекте ``ResultSet``. Вам нужно перебрать список и поискать ``.foo`` в"
" каждом из элементов. Или, если вам действительно нужен только один "
"результат, используйте ``find()`` вместо ``find_all()``. "

#: ../../bs4ru.rst:3574
msgid ""
"``AttributeError: 'NoneType' object has no attribute 'foo'`` - This "
"usually happens because you called ``find()`` and then tried to access "
"the ``.foo`` attribute of the result. But in your case, ``find()`` didn't"
" find anything, so it returned ``None``, instead of returning a tag or a "
"string. You need to figure out why your ``find()`` call isn't returning "
"anything."
msgstr ""
"``AttributeError: 'NoneType' object has no attribute 'foo'`` — это обычно"
" происходит, когда вы вызываете ``find()`` и затем пытаетесь получить "
"доступ к атрибуту ``.foo``. Но в вашем случае ``find()`` не нашел ничего,"
" поэтому вернул ``None`` вместо того, чтобы вернуть тег или строку. Вам "
"нужно выяснить, почему ``find()`` ничего не возвращает. "

#: ../../bs4ru.rst:3581
msgid ""
"``AttributeError: 'NavigableString' object has no attribute 'foo'`` - "
"This usually happens because you're treating a string as though it were a"
" tag. You may be iterating over a list, expecting that it contains "
"nothing but tags, when it actually contains both tags and strings."
msgstr ""
"``AttributeError: 'NavigableString' object has no attribute 'foo'`` - "
"Обычно это происходит, потому что вы обрабатываете строку так, будто это "
"тег. Вы можете проходить по списку, предполагая, что он не содержит "
"ничего, кроме тегов, хотя на самом деле он содержит как теги, так и "
"строки. "

#: ../../bs4ru.rst:3589
msgid "Improving Performance"
msgstr "Повышение производительности "

#: ../../bs4ru.rst:3591
msgid ""
"Beautiful Soup will never be as fast as the parsers it sits on top of. If"
" response time is critical, if you're paying for computer time by the "
"hour, or if there's any other reason why computer time is more valuable "
"than programmer time, you should forget about Beautiful Soup and work "
"directly atop `lxml <http://lxml.de/>`_."
msgstr ""
"Beautiful Soup никогда не будет таким же быстрым, как парсеры, на основе "
"которых он работает. Если время отклика критично, если вы платите за "
"компьютерное время по часам, или если есть какая-то другая причина, "
"почему компьютерное время важнее  программистского, стоит забыть о "
"Beautiful Soup и работать непосредственно с `lxml <http://lxml.de/>`_. "

#: ../../bs4ru.rst:3597
msgid ""
"That said, there are things you can do to speed up Beautiful Soup. If "
"you're not using lxml as the underlying parser, my advice is to "
":ref:`start <parser-installation>`. Beautiful Soup parses documents "
"significantly faster using lxml than using html.parser or html5lib."
msgstr ""
"Тем не менее, есть вещи, которые вы можете сделать, чтобы ускорить "
"Beautiful Soup. Если вы не используете lxml в качестве основного парсера,"
" самое время :ref:`начать <parser-installation>`. Beautiful Soup "
"разбирает документы значительно быстрее с lxml, чем с html.parser или "
"html5lib. "

#: ../../bs4ru.rst:3602
msgid ""
"You can speed up encoding detection significantly by installing the "
"`cchardet <http://pypi.python.org/pypi/cchardet/>`_ library."
msgstr ""
"Вы можете значительно ускорить распознавание кодировок, установив "
"библиотеку `cchardet <http://pypi.python.org/pypi/cchardet/>`_. "

#: ../../bs4ru.rst:3605
msgid ""
"`Parsing only part of a document`_ won't save you much time parsing the "
"document, but it can save a lot of memory, and it'll make *searching* the"
" document much faster."
msgstr ""
"`Разбор части документа`_ не сэкономит много времени в процессе разбора, "
"но может сэкономить много памяти, что сделает *поиск* по документу "
"намного быстрее. "

#: ../../bs4ru.rst:3610
msgid "Translating this documentation"
msgstr "Перевод документации "

#: ../../bs4ru.rst:3612
msgid ""
"New translations of the Beautiful Soup documentation are greatly "
"appreciated. Translations should be licensed under the MIT license, just "
"like Beautiful Soup and its English documentation are."
msgstr ""
"Переводы документации Beautiful Soup очень приветствуются. Перевод должен"
" быть лицензирован по лицензии MIT, так же, как сам Beautiful Soup и "
"англоязычная документация к нему. "

#: ../../bs4ru.rst:3616
msgid ""
"There are two ways of getting your translation into the main code base "
"and onto the Beautiful Soup website:"
msgstr "Есть два способа передать ваш перевод:  "

#: ../../bs4ru.rst:3619
msgid ""
"Create a branch of the Beautiful Soup repository, add your translation, "
"and propose a merge with the main branch, the same as you would do with a"
" proposed change to the source code."
msgstr ""
"Создайте ветку репозитория Beautiful Soup, добавьте свой перевод и "
"предложите слияние с основной веткой — так же, как вы предложили бы "
"изменения исходного кода. "

#: ../../bs4ru.rst:3622
msgid ""
"Send a message to the Beautiful Soup discussion group with a link to your"
" translation, or attach your translation to the message."
msgstr ""
"Отправьте `в дискуссионную группу Beautiful Soup "
"<https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup>`_ "
"сообщение со ссылкой на ваш перевод, или приложите перевод к сообщению. "

#: ../../bs4ru.rst:3625
msgid ""
"Use the Chinese or Brazilian Portuguese translations as your model. In "
"particular, please translate the source file ``doc/index.rst``, rather "
"than the HTML version of the documentation. This makes it possible to "
"publish the documentation in a variety of formats, not just HTML."
msgstr ""
"Используйте существующие переводы документации на китайский или "
"португальский в качестве образца. В частности, переводите исходный файл "
"``doc/index.rst`` вместо того, чтобы переводить HTML-версию "
"документации. Это позволяет публиковать документацию в разных форматах, "
"не только в HTML. "

#: ../../bs4ru.rst:3632
msgid "Beautiful Soup 3"
msgstr "Beautiful Soup 3 "

#: ../../bs4ru.rst:3634
msgid ""
"Beautiful Soup 3 is the previous release series, and is no longer "
"supported. Development of Beautiful Soup 3 stopped in 2012, and the "
"package was completely discontinued in 2021. There's no reason to install"
" it unless you're trying to get very old software to work, but it's "
"published through PyPi as :py:class:`BeautifulSoup`:"
msgstr ""
"Beautiful Soup 3 — это предыдущая серия релизов, которая больше не "
"поддерживается. Разработка Beautiful Soup 3 остановилась в 2012 году, а "
"выпуск пакетов был полностью прекращен в 2021 году. Нет смысла "
"устанавливать его, если только вы не пытаетесь заставить работать очень "
"старое программное обеспечение. Beautiful Soup 3 опубликован через PyPi "
"как :py:class:`BeautifulSoup`:"

#: ../../bs4ru.rst:3640
msgid ":kbd:`$ pip install BeautifulSoup`"
msgstr ":kbd:`$ pip install BeautifulSoup` "

#: ../../bs4ru.rst:3642
msgid ""
"You can also download `a tarball of the final release, 3.2.2 "
"<https://www.crummy.com/software/BeautifulSoup/download/3.x/BeautifulSoup-3.2.2.tar.gz>`_."
msgstr ""
"Вы можете скачать `tar-архив последнего релиза, 3.2.2 "
"<https://www.crummy.com/software/BeautifulSoup/download/3.x/BeautifulSoup-3.2.2.tar.gz>`_."

#: ../../bs4ru.rst:3645
msgid ""
"If you ran ``pip install beautifulsoup`` or ``pip install "
"BeautifulSoup``, but your code doesn't work, you installed Beautiful Soup"
" 3 by mistake. You need to run ``pip install beautifulsoup4``."
msgstr ""
"Если вы запустили ``pip install beautifulsoup`` или ``pip install "
"BeautifulSoup``, но ваш код не работает, значит, вы ошибочно установили "
"Beautiful Soup 3. Вам нужно запустить ``pip install beautifulsoup4``. "

#: ../../bs4ru.rst:3649
msgid ""
"`The documentation for Beautiful Soup 3 is archived online "
"<http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html>`_."
msgstr ""
"Архивная документация для Beautiful Soup 3 доступна `онлайн "
"<http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html>`_. "

#: ../../bs4ru.rst:3653
msgid "Porting code to BS4"
msgstr "Перенос кода на BS4 "

#: ../../bs4ru.rst:3655
msgid ""
"Most code written against Beautiful Soup 3 will work against Beautiful "
"Soup 4 with one simple change. All you should have to do is change the "
"package name from :py:class:`BeautifulSoup` to ``bs4``. So this::"
msgstr ""
"Большая часть кода, написанного для Beautiful Soup 3, будет работать и в "
"Beautiful Soup 4 с одной простой заменой. Все, что вам нужно сделать, это"
" изменить имя пакета c :py:class:`BeautifulSoup` на ``bs4``. Так что "
"это:: "

#: ../../bs4ru.rst:3661
msgid "becomes this::"
msgstr "становится этим:: "

#: ../../bs4ru.rst:3665
msgid ""
"If you get the ``ImportError`` \"No module named BeautifulSoup\", your "
"problem is that you're trying to run Beautiful Soup 3 code, but you only "
"have Beautiful Soup 4 installed."
msgstr ""
"Если выводится сообщение ``ImportError`` \"No module named "
"BeautifulSoup\", ваша проблема в том, что вы пытаетесь запустить код "
"Beautiful Soup 3, в то время как у вас установлен Beautiful Soup 4. "

#: ../../bs4ru.rst:3669
msgid ""
"If you get the ``ImportError`` \"No module named bs4\", your problem is "
"that you're trying to run Beautiful Soup 4 code, but you only have "
"Beautiful Soup 3 installed."
msgstr ""
"Если выводится сообщение ``ImportError`` \"No module named bs4\", ваша "
"проблема в том, что вы пытаетесь запустить код Beautiful Soup 4, в то "
"время как у вас установлен Beautiful Soup 3. "

#: ../../bs4ru.rst:3673
msgid ""
"Although BS4 is mostly backward-compatible with BS3, most of its methods "
"have been deprecated and given new names for `PEP 8 compliance "
"<http://www.python.org/dev/peps/pep-0008/>`_. There are numerous other "
"renames and changes, and a few of them break backward compatibility."
msgstr ""
"Хотя BS4 в основном обратно совместим с BS3, большинство методов BS3 "
"устарели и получили новые имена, чтобы `соответствовать PEP 8 "
"<http://www.python.org/dev/peps/pep-0008/>`_. Некоторые из переименований"
" и изменений нарушают обратную совместимость. "

#: ../../bs4ru.rst:3678
msgid ""
"Here's what you'll need to know to convert your BS3 code and habits to "
"BS4:"
msgstr "Вот что нужно знать, чтобы перейти с BS3 на BS4: "

#: ../../bs4ru.rst:3681
msgid "You need a parser"
msgstr "Вам нужен парсер "

#: ../../bs4ru.rst:3683
msgid ""
"Beautiful Soup 3 used Python's ``SGMLParser``, a module that was "
"deprecated and removed in Python 3.0. Beautiful Soup 4 uses "
"``html.parser`` by default, but you can plug in lxml or html5lib and use "
"that instead. See `Installing a parser`_ for a comparison."
msgstr ""
"Beautiful Soup 3 использовал модуль Python ``SGMLParser``, который теперь"
" устарел и был удален в Python 3.0. Beautiful Soup 4 по умолчанию "
"использует ``html.parser``, но вы можете подключить lxml или html5lib "
"вместо него. Вы найдете таблицу сравнения парсеров в разделе `Установка "
"парсера`_. "

#: ../../bs4ru.rst:3688
msgid ""
"Since ``html.parser`` is not the same parser as ``SGMLParser``, you may "
"find that Beautiful Soup 4 gives you a different parse tree than "
"Beautiful Soup 3 for the same markup. If you swap out ``html.parser`` for"
" lxml or html5lib, you may find that the parse tree changes yet again. If"
" this happens, you'll need to update your scraping code to process the "
"new tree."
msgstr ""
"Поскольку ``html.parser`` — это не то же, что ``SGMLParser``, вы можете "
"обнаружить, что Beautiful Soup 4 дает другое дерево разбора, чем "
"Beautiful Soup 3. Если вы замените html.parser на lxml или html5lib, "
"может оказаться, что дерево разбора опять изменилось. Если такое "
"случится, вам придется обновить код, чтобы обработать новое дерево. "

#: ../../bs4ru.rst:3696
msgid "Property names"
msgstr "Имена методов "

#: ../../bs4ru.rst:3698
msgid ""
"I renamed three attributes to avoid using words that have special meaning"
" to Python. Unlike my changes to method names (which you'll see in the "
"form of deprecation warnings), these changes *did not preserve backwards "
"compatibility.* If you used these attributes in BS3, your code will break"
" in BS4 until you change them."
msgstr ""
"Я переименовал три атрибута, чтобы избежать использования "
"зарезервированных слов в Python. В отличие от моих изменений в названиях методов "
"(которые вы увидите в виде предупреждений об устаревших методах), эти изменения *не "
"являются обратно совместимыми*. Если вы использовали эти атрибуты в BS3, "
"ваш код не сработает на BS4, пока вы их не измените. "

#: ../../bs4ru.rst:3704
msgid "``UnicodeDammit.unicode`` -> ``UnicodeDammit.unicode_markup``"
msgstr "``UnicodeDammit.unicode`` -> ``UnicodeDammit.unicode_markup``"

#: ../../bs4ru.rst:3705
msgid "``Tag.next`` -> ``Tag.next_element``"
msgstr "``Tag.next`` -> ``Tag.next_element``"

#: ../../bs4ru.rst:3706
msgid "``Tag.previous`` -> ``Tag.previous_element``"
msgstr "``Tag.previous`` -> ``Tag.previous_element``"

#: ../../bs4ru.rst:3710
msgid "Generators"
msgstr "Генераторы "

#: ../../bs4ru.rst:3712
msgid ""
"Some of the generators used to yield ``None`` after they were done, and "
"then stop. That was a bug. Now the generators just stop."
msgstr ""
"Некоторые генераторы выдавали ``None`` после их завершения и "
"останавливались. Это была ошибка. Теперь генераторы просто "
"останавливаются. "

#: ../../bs4ru.rst:3716
msgid "XML"
msgstr "XML "

#: ../../bs4ru.rst:3718
msgid ""
"There is no longer a ``BeautifulStoneSoup`` class for parsing XML. To "
"parse XML you pass in \"xml\" as the second argument to the "
":py:class:`BeautifulSoup` constructor. For the same reason, the "
":py:class:`BeautifulSoup` constructor no longer recognizes the ``isHTML``"
" argument."
msgstr ""
"Больше нет класса ``BeautifulStoneSoup`` для разбора XML. Чтобы разобрать"
" XML, нужно передать \"xml\" в качестве второго аргумента в конструктор "
":py:class:`BeautifulSoup`. По той же причине конструктор "
":py:class:`BeautifulSoup` больше не распознает аргумент  ``isHTML``. "

#: ../../bs4ru.rst:3724
msgid ""
"Beautiful Soup's handling of empty-element XML tags has been improved. "
"Previously when you parsed XML you had to explicitly say which tags were "
"considered empty-element tags. The ``selfClosingTags`` argument to the "
"constructor is no longer recognized. Instead, Beautiful Soup considers "
"any empty tag to be an empty-element tag. If you add a child to an empty-"
"element tag, it stops being an empty-element tag."
msgstr ""
"Улучшена обработка пустых тегов XML. Ранее при разборе XML нужно было "
"явно указать, какие теги считать пустыми элементами. Аргумент "
"``SelfClosingTags`` больше не распознается. Вместо этого Beautiful Soup "
"считает пустым элементом любой тег без содержимого. Если вы добавляете в "
"тег дочерний элемент, тег больше не считается пустым элементом. "

#: ../../bs4ru.rst:3733
msgid "Entities"
msgstr "Мнемоники "

#: ../../bs4ru.rst:3735
msgid ""
"An incoming HTML or XML entity is always converted into the corresponding"
" Unicode character. Beautiful Soup 3 had a number of overlapping ways of "
"dealing with entities, which have been removed. The "
":py:class:`BeautifulSoup` constructor no longer recognizes the "
"``smartQuotesTo`` or ``convertEntities`` arguments. (`Unicode, Dammit`_ "
"still has ``smart_quotes_to``, but its default is now to turn smart "
"quotes into Unicode.) The constants ``HTML_ENTITIES``, ``XML_ENTITIES``, "
"and ``XHTML_ENTITIES`` have been removed, since they configure a feature "
"(transforming some but not all entities into Unicode characters) that no "
"longer exists."
msgstr ""
"Входящие мнемоники HTML или XML всегда преобразуются в соответствующие "
"символы Unicode. В Beautiful Soup 3 было несколько перекрывающих друг "
"друга способов взаимодействия с мнемониками. Эти способы удалены. "
"Конструктор :py:class:`BeautifulSoup` больше не распознает аргументы "
"``smartQuotesTo`` и ``convertEntities``. (В `Unicode, Dammit`_ все еще "
"присутствует ``smart_quotes_to``, но по умолчанию парные кавычки "
"преобразуются в Unicode). Константы ``HTML_ENTITIES``, ``XML_ENTITIES`` и"
" ``XHTML_ENTITIES`` были удалены, так как они служили для настройки "
"функции, которой больше нет (преобразование отдельных мнемоник в символы "
"Unicode). "

#: ../../bs4ru.rst:3746
msgid ""
"If you want to turn Unicode characters back into HTML entities on output,"
" rather than turning them into UTF-8 characters, you need to use an "
":ref:`output formatter <output_formatters>`."
msgstr ""
"Если вы хотите на выходе преобразовать символы Unicode обратно в "
"мнемоники HTML, а не превращать Unicode в символы UTF-8, вам нужно "
"использовать :ref:`средства форматирования вывода <output_formatters>`. "

#: ../../bs4ru.rst:3753
msgid ""
":ref:`Tag.string <.string>` now operates recursively. If tag A contains a"
" single tag B and nothing else, then A.string is the same as B.string. "
"(Previously, it was None.)"
msgstr ""
":ref:`Tag.string <.string>` теперь работает рекурсивно. Если тег А "
"содержит только тег B и ничего больше, тогда значение A.string будет "
"таким же, как B.string. (Раньше это был None.) "

#: ../../bs4ru.rst:3757
msgid ""
"`Multi-valued attributes`_ like ``class`` have lists of strings as their "
"values, not simple strings. This may affect the way you search by CSS "
"class."
msgstr ""
"`Многозначные атрибуты`_, такие как ``class``, теперь в качестве значений"
" имеют списки строк, а не простые строки. Это может повлиять на поиск по "
"классу CSS. "

#: ../../bs4ru.rst:3761
msgid ""
":py:class:`Tag` objects now implement the ``__hash__`` method, such that "
"two :py:class:`Tag` objects are considered equal if they generate the "
"same markup. This may change your script's behavior if you put "
":py:class:`Tag` objects into a dictionary or set."
msgstr ""
"Объекты :py:class:`Tag` теперь реализуют метод ``__hash__``, так что два "
"объекта :py:class:`Tag` считаются равными, если они генерируют одинаковую"
" разметку. Это может изменить поведение вашего скрипта, если вы поместите"
" объект :py:class:`Tag` в словарь (dictionary) или множество (set). "

#: ../../bs4ru.rst:3766
msgid ""
"If you pass one of the ``find*`` methods both :ref:`string <string>` "
"*and* a tag-specific argument like :ref:`name <name>`, Beautiful Soup "
"will search for tags that match your tag-specific criteria and whose "
":ref:`Tag.string <.string>` matches your :ref:`string <string>` value. It"
" will *not* find the strings themselves. Previously, Beautiful Soup "
"ignored the tag-specific arguments and looked for strings."
msgstr ""
"Если вы передадите в один из методов ``find*`` одновременно :ref:`string "
"<string>` *и* специфичный для тега аргумент, такой как :ref:`name "
"<name>`, Beautiful Soup будет искать теги, которые, во-первых,  "
"соответствуют специфичным для тега критериям, и, во-вторых, имеют "
":ref:`Tag.string <.string>`, соответствующий заданному вами значению "
":ref:`string <string>`. Beautiful Soup *не* найдет сами строки. Ранее "
"Beautiful Soup игнорировал аргументы, специфичные для тегов, и искал "
"строки. "

#: ../../bs4ru.rst:3774
msgid ""
"The :py:class:`BeautifulSoup` constructor no longer recognizes the "
"``markupMassage`` argument. It's now the parser's responsibility to "
"handle markup correctly."
msgstr ""
"Конструктор :py:class:`BeautifulSoup` больше не распознает аргумент "
"`markupMassage`. Теперь это задача парсера — обрабатывать разметку "
"правильно. "

#: ../../bs4ru.rst:3778
msgid ""
"The rarely-used alternate parser classes like "
"``ICantBelieveItsBeautifulSoup`` and ``BeautifulSOAP`` have been removed."
" It's now the parser's decision how to handle ambiguous markup."
msgstr ""
"Редко используемые альтернативные классы парсеров, такие как "
"``ICantBelieveItsBeautifulSoup`` и ``BeautifulSOAP``, удалены. Теперь "
"парсер решает, что делать с неоднозначной разметкой. "

#: ../../bs4ru.rst:3783
msgid "The ``prettify()`` method now returns a Unicode string, not a bytestring."
msgstr ""
"Метод ``prettify()`` теперь возвращает строку Unicode, а не байтовую "
"строку. "

#~ msgid ""
#~ "If you can, I recommend you "
#~ "install and use lxml for speed. If"
#~ " you're using a very old version "
#~ "of Python -- earlier than 3.2.2 --"
#~ " it's `essential` that you install "
#~ "lxml or html5lib. Python's built-in "
#~ "HTML parser is just not very good"
#~ " in those old versions."
#~ msgstr ""
#~ "Я рекомендую по возможности установить и"
#~ " использовать lxml для быстродействия. Если"
#~ " вы используете очень старую версию "
#~ "Python — более ранню, чем 3.2.2 --"
#~ " `необходимо` установить lxml или html5lib,"
#~ " потому что встроенный в Python "
#~ "парсер HTML просто недостаточно хорош в"
#~ " старых версиях. "

#~ msgid "``Tag``"
#~ msgstr "``Tag`` "

#~ msgid "Name"
#~ msgstr "Name "

#~ msgid "Attributes"
#~ msgstr "Атрибуты "

#~ msgid "``NavigableString``"
#~ msgstr "``NavigableString`` "

#~ msgid "``BeautifulSoup``"
#~ msgstr "``BeautifulSoup`` "

#~ msgid "Comments and other special strings"
#~ msgstr "Комментарии и другие специфичные строки "

#~ msgid ""
#~ "Beautiful Soup also defines classes "
#~ "called ``Stylesheet``, ``Script``, and "
#~ "``TemplateString``, for embedded CSS "
#~ "stylesheets (any strings found inside a"
#~ " ``<style>`` tag), embedded Javascript (any"
#~ " strings found in a ``<script>`` "
#~ "tag), and HTML templates (any strings"
#~ " inside a ``<template>`` tag). These "
#~ "classes work exactly the same way "
#~ "as ``NavigableString``; their only purpose "
#~ "is to make it easier to pick "
#~ "out the main body of the page, "
#~ "by ignoring strings that represent "
#~ "something else. `(These classes are new"
#~ " in Beautiful Soup 4.9.0, and the "
#~ "html5lib parser doesn't use them.)`"
#~ msgstr ""
#~ "В Beautiful Soup также определены классы"
#~ " ``Stylesheet``, ``Script`` и ``TemplateString``"
#~ " для встроенных таблиц стилей CSS "
#~ "(любые строки внутри тега  ``<style>``), "
#~ "встроенного Javascript (любые строки в "
#~ "теге ``<script>``) и шаблонов HTML "
#~ "(любые строки в теге ``<template>``). "
#~ "Эти классы работают точно так же, "
#~ "как ``NavigableString``; их единственная цель"
#~ " — облегчить извлечение основной части "
#~ "страницы, игнорируя строки, которые "
#~ "представляют что-то еще. `(Эти классы "
#~ "являются новыми в Beautiful Soup 4.9.0,"
#~ " и парсер html5lib их не "
#~ "использует.)`   "

#~ msgid ""
#~ "Beautiful Soup defines classes for "
#~ "anything else that might show up "
#~ "in an XML document: ``CData``, "
#~ "``ProcessingInstruction``, ``Declaration``, and "
#~ "``Doctype``. Like ``Comment``, these classes"
#~ " are subclasses of ``NavigableString`` that"
#~ " add something extra to the string."
#~ " Here's an example that replaces the"
#~ " comment with a CDATA block::"
#~ msgstr ""
#~ "Beautiful Soup определяет классы для "
#~ "всего, что может появиться в "
#~ "XML-документе: ``CData``, ``ProcessingInstruction``, "
#~ "``Declaration`` и ``Doctype``. Как и "
#~ "``Comment``, эти классы являются подклассами"
#~ " ``NavigableString``, которые добавляют что-то"
#~ " еще к строке. Вот пример, который"
#~ " заменяет комментарий блоком CDATA::   "

#~ msgid ""
#~ "``BeautifulSoup`` has a ``.select()`` method"
#~ " which uses the `SoupSieve "
#~ "<https://facelessuser.github.io/soupsieve/>`_ package to"
#~ " run a CSS selector against a "
#~ "parsed document and return all the "
#~ "matching elements. ``Tag`` has a similar"
#~ " method which runs a CSS selector "
#~ "against the contents of a single "
#~ "tag."
#~ msgstr ""
#~ "В ``BeautifulSoup`` есть метод ``.select()``,"
#~ " который использует `SoupSieve "
#~ "<https://facelessuser.github.io/soupsieve/>`_ , чтобы "
#~ "запустить селектор CSS и вернуть все "
#~ "подходящие элементы. В ``Tag`` есть "
#~ "похожий метод, который запускает селектор "
#~ "CSS в отношении содержимого одного тега."
#~ " "

#~ msgid "You can find tags::"
#~ msgstr "Вы можете найти теги:: "

#~ msgid "``SoupStrainer``"
#~ msgstr "``SoupStrainer`` "

#~ msgid ":kbd:`$ easy_install html5lib`"
#~ msgstr ":kbd:`$ easy_install html5lib` "

#~ msgid "Lenient (As of Python 3.2)"
#~ msgstr "Нестрогий (в Python 3.2) "

#~ msgid "Lenient"
#~ msgstr "Нестрогий "

#~ msgid ""
#~ "The simplest way to navigate the "
#~ "parse tree is to say the name "
#~ "of the tag you want. If you "
#~ "want the <head> tag, just say "
#~ "``soup.head``::"
#~ msgstr ""
#~ "Самый простой способ навигации по дереву"
#~ " разбора — это указать имя тега, "
#~ "который вам нужен. Если вы хотите "
#~ "получить тег <head>, просто напишите "
#~ "``soup.head``:: "

#~ msgid ""
#~ "If you need to get `all` the "
#~ "<a> tags, or anything more complicated"
#~ " than the first tag with a "
#~ "certain name, you'll need to use "
#~ "one of the methods described in "
#~ "`Searching the tree`_, such as "
#~ "`find_all()`::"
#~ msgstr ""
#~ "Если вам нужно получить `все` теги "
#~ "<a> или что-нибудь более сложное, чем"
#~ " первый тег с определенным именем, "
#~ "вам нужно использовать один из методов,"
#~ " описанных в разделе `Поиск по "
#~ "дереву`_, такой как `find_all()`:: "

#~ msgid ""
#~ "If you pass in a function to "
#~ "filter on a specific attribute like "
#~ "``href``, the argument passed into the"
#~ " function will be the attribute "
#~ "value, not the whole tag. Here's a"
#~ " function that finds all ``a`` tags"
#~ " whose ``href`` attribute *does not* "
#~ "match a regular expression::"
#~ msgstr ""
#~ "Если вы передаете функцию для фильтрации"
#~ " по определенному атрибуту, такому как "
#~ "``href``, аргументом, переданным в функцию,"
#~ " будет значение атрибута, а не весь"
#~ " тег. Вот функция, которая находит "
#~ "все теги ``a``, у которых атрибут "
#~ "``href`` *не* соответствует регулярному "
#~ "выражению::   "

#~ msgid ""
#~ "Any argument that's not recognized will"
#~ " be turned into a filter on one"
#~ " of a tag's attributes. If you "
#~ "pass in a value for an argument"
#~ " called ``id``, Beautiful Soup will "
#~ "filter against each tag's 'id' "
#~ "attribute::"
#~ msgstr ""
#~ "Любой нераспознанный аргумент будет превращен"
#~ " в фильтр по атрибуту тега. Если "
#~ "вы передаете значение для аргумента с"
#~ " именем ``id``, Beautiful Soup будет "
#~ "фильтровать по атрибуту \"id\" каждого "
#~ "тега:: "

#~ msgid ""
#~ "This code finds all tags whose "
#~ "``id`` attribute has a value, regardless"
#~ " of what the value is::"
#~ msgstr ""
#~ "Следующий код находит все теги, атрибут"
#~ " ``id`` которых имеет значение, независимо"
#~ " от того, что это за значение:: \n"
#~ ""
#~ "\n"

#~ msgid ""
#~ "Because ``find_all()`` is the most "
#~ "popular method in the Beautiful Soup "
#~ "search API, you can use a shortcut"
#~ " for it. If you treat the "
#~ ":py:class:`BeautifulSoup` object or a "
#~ ":py:class:`Tag` object as though it were"
#~ " a function, then it's the same "
#~ "as calling ``find_all()`` on that "
#~ "object. These two lines of code "
#~ "are equivalent::"
#~ msgstr ""
#~ "Поскольку ``find_all()`` является самым "
#~ "популярным методом в Beautiful Soup API,"
#~ " вы можете использовать сокращенную запись."
#~ " Если относиться к объекту  "
#~ ":py:class:`BeautifulSoup` или объекту "
#~ ":py:class:`Tag` так, будто это функция, "
#~ "то это похоже на вызов ``find_all()``"
#~ " ﻿с этим объектом. Эти две строки "
#~ "кода эквивалентны:: "

#~ msgid ""
#~ "The most common parse errors are "
#~ "``HTMLParser.HTMLParseError: malformed start tag``"
#~ " and ``HTMLParser.HTMLParseError: bad end "
#~ "tag``. These are both generated by "
#~ "Python's built-in HTML parser library,"
#~ " and the solution is to :ref:`install"
#~ " lxml or html5lib. <parser-installation>`"
#~ msgstr ""
#~ "Наиболее распространенные ошибки разбора — "
#~ "это ``HTMLParser.HTMLParseError: malformed start "
#~ "tag`` и ``HTMLParser.HTMLParseError: bad end"
#~ " tag``. Они оба генерируются встроенным "
#~ "в Python парсером HTML, и решением "
#~ "будет :ref:`установить lxml или html5lib. "
#~ "<parser-installation>` "

#~ msgid ""
#~ "The most common type of unexpected "
#~ "behavior is that you can't find a"
#~ " tag that you know is in the"
#~ " document. You saw it going in, "
#~ "but ``find_all()`` returns ``[]`` or "
#~ "``find()`` returns ``None``. This is "
#~ "another common problem with Python's "
#~ "built-in HTML parser, which sometimes "
#~ "skips tags it doesn't understand.  "
#~ "Again, the best solution is to "
#~ ":ref:`install lxml or html5lib. <parser-"
#~ "installation>`"
#~ msgstr ""
#~ "Наиболее распространенный тип неожиданного "
#~ "поведения — когда вы не можете "
#~ "найти тег, который точно есть в "
#~ "документе. Вы видели его на входе, "
#~ "но ``find_all()`` возвращает ``[]``, или "
#~ "``find()`` возвращает ``None``. Это еще "
#~ "одна распространенная проблема со встроенным"
#~ " в Python парсером HTML, который "
#~ "иногда пропускает теги, которые он не"
#~ " понимает.  Опять же, решение заключается"
#~ " в :ref:`установке lxml или html5lib "
#~ "<parser-installation>`. "

#~ msgid ""
#~ "Beautiful Soup 3 is the previous "
#~ "release series, and is no longer "
#~ "being actively developed. It's currently "
#~ "packaged with all major Linux "
#~ "distributions:"
#~ msgstr ""
#~ "Beautiful Soup 3 — предыдущая версия,"
#~ " и она больше активно не развивается."
#~ " На текущий момент Beautiful Soup 3"
#~ " поставляется со всеми основными "
#~ "дистрибутивами Linux: "

#~ msgid ":kbd:`$ apt-get install python-beautifulsoup`"
#~ msgstr ":kbd:`$ apt-get install python-beautifulsoup` "

#~ msgid "It's also published through PyPi as :py:class:`BeautifulSoup`.:"
#~ msgstr "Он также публикуется через PyPi как :py:class:`BeautifulSoup`: "

#~ msgid ":kbd:`$ easy_install BeautifulSoup`"
#~ msgstr ":kbd:`$ easy_install BeautifulSoup` "

#~ msgid ""
#~ "soup.find_all(id=True) # [<a class=\"sister\" "
#~ "href=\"http://example.com/elsie\" id=\"link1\">Elsie</a>, "
#~ "#  <a class=\"sister\" "
#~ "href=\"http://example.com/lacie\" id=\"link2\">Lacie</a>, "
#~ "#  <a class=\"sister\" "
#~ "href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>]"
#~ msgstr ""

#~ msgid ""
#~ "If you pass in a list for an"
#~ " argument, Beautiful Soup will look "
#~ "for an attribute-value match against "
#~ "`any` string, regular expression, or "
#~ "function in that list. This code "
#~ "finds the first and last link:"
#~ msgstr ""

#~ msgid ""
#~ "soup.find_all(id=[\"link1\", re.compile(\"3$\")]) # "
#~ "[<a class=\"sister\" href=\"http://example.com/elsie\" "
#~ "id=\"link1\">Elsie</a>, #  <a class=\"sister\" "
#~ "href=\"http://example.com/tillie\" id=\"link3\">Tillie</a>]"
#~ msgstr ""

#~ msgid ""
#~ "This is because two different "
#~ ":py:class:`Tag` objects can't occupy the "
#~ "same space at the same time."
#~ msgstr ""
#~ "Это потому, что два разных объекта "
#~ ":py:class:`Tag` не могут занимать одно и"
#~ " то же пространство в одно и то"
#~ " же время. "

#~ msgid ""
#~ "You can also pass a "
#~ ":py:class:`SoupStrainer` into any of the "
#~ "methods covered in `Searching the "
#~ "tree`_. This probably isn't terribly "
#~ "useful, but I thought I'd mention "
#~ "it::"
#~ msgstr ""
#~ "Вы также можете передать "
#~ ":py:class:`SoupStrainer` в любой из методов."
#~ " описанных в разделе `Поиск по "
#~ "дереву`_. Может, это не безумно полезно,"
#~ " но я решил упомянуть:: "

#~ msgid "``renderContents`` -> ``encode_contents``"
#~ msgstr "``renderContents`` -> ``encode_contents``"

#~ msgid "``replaceWith`` -> ``replace_with``"
#~ msgstr "``replaceWith`` -> ``replace_with``"

#~ msgid "``replaceWithChildren`` -> ``unwrap``"
#~ msgstr "``replaceWithChildren`` -> ``unwrap``"

#~ msgid "``findAll`` -> ``find_all``"
#~ msgstr "``findAll`` -> ``find_all``"

#~ msgid "``findAllNext`` -> ``find_all_next``"
#~ msgstr "``findAllNext`` -> ``find_all_next``"

#~ msgid "``findAllPrevious`` -> ``find_all_previous``"
#~ msgstr "``findAllPrevious`` -> ``find_all_previous``"

#~ msgid "``findNext`` -> ``find_next``"
#~ msgstr "``findNext`` -> ``find_next``"

#~ msgid "``findNextSibling`` -> ``find_next_sibling``"
#~ msgstr "``findNextSibling`` -> ``find_next_sibling``"

#~ msgid "``findNextSiblings`` -> ``find_next_siblings``"
#~ msgstr "``findNextSiblings`` -> ``find_next_siblings``"

#~ msgid "``findParent`` -> ``find_parent``"
#~ msgstr "``findParent`` -> ``find_parent``"

#~ msgid "``findParents`` -> ``find_parents``"
#~ msgstr "``findParents`` -> ``find_parents``"

#~ msgid "``findPrevious`` -> ``find_previous``"
#~ msgstr "``findPrevious`` -> ``find_previous``"

#~ msgid "``findPreviousSibling`` -> ``find_previous_sibling``"
#~ msgstr "``findPreviousSibling`` -> ``find_previous_sibling``"

#~ msgid "``findPreviousSiblings`` -> ``find_previous_siblings``"
#~ msgstr "``findPreviousSiblings`` -> ``find_previous_siblings``"

#~ msgid "``getText`` -> ``get_text``"
#~ msgstr "``getText`` -> ``get_text``"

#~ msgid "``nextSibling`` -> ``next_sibling``"
#~ msgstr "``nextSibling`` -> ``next_sibling``"

#~ msgid "``previousSibling`` -> ``previous_sibling``"
#~ msgstr "``previousSibling`` -> ``previous_sibling``"

#~ msgid ""
#~ "Some arguments to the Beautiful Soup "
#~ "constructor were renamed for the same"
#~ " reasons:"
#~ msgstr ""
#~ "Некоторые аргументы конструктора Beautiful "
#~ "Soup были переименованы по той же "
#~ "причине: "

#~ msgid ""
#~ "``BeautifulSoup(parseOnlyThese=...)`` -> "
#~ "``BeautifulSoup(parse_only=...)``"
#~ msgstr ""
#~ "``BeautifulSoup(parseOnlyThese=...)`` -> "
#~ "``BeautifulSoup(parse_only=...)``"

#~ msgid ""
#~ "``BeautifulSoup(fromEncoding=...)`` -> "
#~ "``BeautifulSoup(from_encoding=...)``"
#~ msgstr ""
#~ "``BeautifulSoup(fromEncoding=...)`` -> "
#~ "``BeautifulSoup(from_encoding=...)``"

#~ msgid "I renamed one method for compatibility with Python 3:"
#~ msgstr "Я переименовал один метод для совместимости с Python 3: "

#~ msgid "``Tag.has_key()`` -> ``Tag.has_attr()``"
#~ msgstr "``Tag.has_key()`` -> ``Tag.has_attr()``"

#~ msgid "I renamed one attribute to use more accurate terminology:"
#~ msgstr ""
#~ "Я переименовал один атрибут, чтобы "
#~ "использовать более точную терминологию: "

#~ msgid "``Tag.isSelfClosing`` -> ``Tag.is_empty_element``"
#~ msgstr "``Tag.isSelfClosing`` -> ``Tag.is_empty_element``"

#~ msgid ""
#~ "These methods are left over from "
#~ "the Beautiful Soup 2 API. They've "
#~ "been deprecated since 2006 and should"
#~ " not be used at all:"
#~ msgstr ""
#~ "Следующие методы остались от API "
#~ "Beautiful Soup 2; они устарели с "
#~ "2006 года, и их не следует "
#~ "использоваться вовсе: "

#~ msgid "``Tag.fetchNextSiblings``"
#~ msgstr "``Tag.fetchNextSiblings``"

#~ msgid "``Tag.fetchPreviousSiblings``"
#~ msgstr "``Tag.fetchPreviousSiblings``"

#~ msgid "``Tag.fetchPrevious``"
#~ msgstr "``Tag.fetchPrevious``"

#~ msgid "``Tag.fetchParents``"
#~ msgstr "``Tag.fetchParents``"

#~ msgid "``Tag.findChild``"
#~ msgstr "``Tag.findChild``"

#~ msgid "``Tag.findChildren``"
#~ msgstr "``Tag.findChildren``"

#~ msgid ""
#~ "I gave the generators PEP 8-compliant"
#~ " names, and transformed them into "
#~ "properties:"
#~ msgstr ""
#~ "Я дал генераторам PEP 8-совместимые "
#~ "имена и преобразовал их в свойства: \n"

#~ msgid "``childGenerator()`` -> ``children``"
#~ msgstr "``childGenerator()`` -> ``children``"

#~ msgid "``nextGenerator()`` -> ``next_elements``"
#~ msgstr "``nextGenerator()`` -> ``next_elements``"

#~ msgid "``nextSiblingGenerator()`` -> ``next_siblings``"
#~ msgstr "``nextSiblingGenerator()`` -> ``next_siblings``"

#~ msgid "``previousGenerator()`` -> ``previous_elements``"
#~ msgstr "``previousGenerator()`` -> ``previous_elements``"

#~ msgid "``previousSiblingGenerator()`` -> ``previous_siblings``"
#~ msgstr "``previousSiblingGenerator()`` -> ``previous_siblings``"

#~ msgid "``recursiveChildGenerator()`` -> ``descendants``"
#~ msgstr "``recursiveChildGenerator()`` -> ``descendants``"

#~ msgid "``parentGenerator()`` -> ``parents``"
#~ msgstr "``parentGenerator()`` -> ``parents``"

#~ msgid "So instead of this::"
#~ msgstr "Так что вместо этого:: "

#~ msgid "You can write this::"
#~ msgstr "Вы можете написать это:: "

#~ msgid "(But the old code will still work.)"
#~ msgstr "(Хотя старый код тоже будет работать.) "

#~ msgid ""
#~ "There are two new generators, "
#~ ":ref:`.strings and .stripped_strings <string-"
#~ "generators>`. ``.strings`` yields NavigableString"
#~ " objects, and ``.stripped_strings`` yields "
#~ "Python strings that have had whitespace"
#~ " stripped."
#~ msgstr ""
#~ "Добавились два генератора: :ref:`.strings и"
#~ " .stripped_strings <string-generators>`. "
#~ "``.strings`` выдает объекты NavigableString, а"
#~ " ``.stripped_strings`` выдает строки Python, "
#~ "у которых удалены пробелы. "

